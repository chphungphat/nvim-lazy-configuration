This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: ./**.lua
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
lua/
  core/
    command.lua
    keymap.lua
    lazy.lua
    option.lua
  plugins/
    coding/
      blink-cmp.lua
      conform.lua
      lspconfig.lua
      mason.lua
      none-ls.lua
      nvim-dap.lua
      nvim-lint.lua
    colorschemes/
      gruvbox-material.lua
    comment.lua
    fidget.lua
    fzf-lua.lua
    gitsigns.lua
    hlchunk.lua
    lazydev.lua
    nvim-autopairs.lua
    nvim-highlight-colors.lua
    nvim-surround.lua
    nvim-tree.lua
    nvim-treesitter.lua
    slimline.lua
    stcursorword.lua
    treesj.lua
init.lua
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lua/plugins/coding/none-ls.lua">
if true then
  return {}
end
return {
  "nvimtools/none-ls.nvim",
  ft = {
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact",
    "vue",
    "svelte",
  },
  dependencies = {
    "nvim-lua/plenary.nvim",
    "nvimtools/none-ls-extras.nvim",
  },
  config = function()
    local null_ls = require("null-ls")

    local eslint_disable_rule = {
      method = null_ls.methods.CODE_ACTION,
      filetypes = { "javascript", "javascriptreact", "typescript", "typescriptreact", "vue" },
      generator = {
        fn = function(params)
          local actions = {}

          -- Get diagnostics for current line
          local diagnostics = vim.diagnostic.get(params.bufnr, {
            lnum = params.row - 1
          })

          for _, diagnostic in ipairs(diagnostics) do
            if diagnostic.source == "eslint" and diagnostic.code then
              local rule = tostring(diagnostic.code)

              -- Action to disable rule for next line
              table.insert(actions, {
                title = "Disable ESLint rule '" .. rule .. "' for this line",
                action = function()
                  local line_num = params.row
                  local comment = "// eslint-disable-next-line " .. rule
                  vim.api.nvim_buf_set_lines(params.bufnr, line_num - 1, line_num - 1, false, { comment })
                end,
              })

              -- Action to disable rule for entire file
              table.insert(actions, {
                title = "Disable ESLint rule '" .. rule .. "' for entire file",
                action = function()
                  local comment = "/* eslint-disable " .. rule .. " */"
                  vim.api.nvim_buf_set_lines(params.bufnr, 0, 0, false, { comment, "" })
                end,
              })

              -- Action to open ESLint documentation
              table.insert(actions, {
                title = "Open ESLint documentation for '" .. rule .. "'",
                action = function()
                  local url = "https://eslint.org/docs/rules/" .. rule
                  local open_cmd
                  if vim.fn.has("mac") == 1 then
                    open_cmd = "open"
                  elseif vim.fn.has("unix") == 1 then
                    open_cmd = "xdg-open"
                  elseif vim.fn.has("win32") == 1 then
                    open_cmd = "start"
                  end

                  if open_cmd then
                    vim.fn.system(open_cmd .. " " .. url)
                    vim.notify("Opening ESLint docs for: " .. rule, vim.log.levels.INFO)
                  end
                end,
              })
            end
          end

          return actions
        end,
      },
    }

    null_ls.setup({
      sources = {
        -- ESLint diagnostics and code actions
        null_ls.builtins.diagnostics.eslint_d,
        null_ls.builtins.code_actions.eslint_d,

        -- Custom ESLint disable rule actions
        eslint_disable_rule,

        -- Formatting
        null_ls.builtins.formatting.prettier,
      },

      -- Enhanced on_attach for better ESLint integration
      on_attach = function(client, bufnr)
        -- Auto-format on save if formatter is available
        if client.supports_method("textDocument/formatting") then
          vim.api.nvim_create_autocmd("BufWritePre", {
            buffer = bufnr,
            callback = function()
              vim.lsp.buf.format({
                bufnr = bufnr,
                filter = function(c)
                  return c.name == "null-ls"
                end,
              })
            end,
          })
        end
      end,
    })

    -- Quick keymap for ESLint-specific actions
    vim.keymap.set("n", "<leader>ce", function()
      local line = vim.fn.line(".")
      local diagnostics = vim.diagnostic.get(0, { lnum = line - 1 })
      local eslint_diagnostic = nil

      for _, d in ipairs(diagnostics) do
        if d.source == "eslint" and d.code then
          eslint_diagnostic = d
          break
        end
      end

      if not eslint_diagnostic then
        vim.notify("No ESLint rule found on current line", vim.log.levels.WARN)
        return
      end

      local rule = tostring(eslint_diagnostic.code)
      local choices = {
        "Disable for this line",
        "Disable for entire file",
        "Open documentation",
      }

      vim.ui.select(choices, {
        prompt = "ESLint rule '" .. rule .. "':",
        format_item = function(item)
          return "🔧 " .. item
        end,
      }, function(choice)
        if not choice then return end

        if choice:match("this line") then
          local comment = "// eslint-disable-next-line " .. rule
          vim.api.nvim_buf_set_lines(0, line - 1, line - 1, false, { comment })
        elseif choice:match("entire file") then
          local comment = "/* eslint-disable " .. rule .. " */"
          vim.api.nvim_buf_set_lines(0, 0, 0, false, { comment, "" })
        elseif choice:match("documentation") then
          local url = "https://eslint.org/docs/rules/" .. rule
          local open_cmd = vim.fn.has("mac") == 1 and "open" or
              vim.fn.has("unix") == 1 and "xdg-open" or
              vim.fn.has("win32") == 1 and "start" or nil
          if open_cmd then
            vim.fn.system(open_cmd .. " " .. url)
            vim.notify("Opening ESLint docs for: " .. rule, vim.log.levels.INFO)
          end
        end
      end)
    end, { desc = "ESLint rule actions" })
  end,
}
</file>

<file path="lua/plugins/nvim-highlight-colors.lua">
return {
	"brenoprata10/nvim-highlight-colors",
	config = function()
		require("nvim-highlight-colors").setup({
			render = "background",
			virtual_symbol = "■",
			enable_hex = true,
			enable_short_hex = true,
			enable_rgb = true,
			enable_hsl = true,
			enable_var_usage = true,
			enable_named_colors = true,
			enable_tailwind = false,

			---Set custom colors
			---Label must be properly escaped with '%' to adhere to `string.gmatch`
			--- :help string.gmatch
			custom_colors = {
				{ label = "%-%-theme%-primary%-color", color = "#0f1219" },
				{ label = "%-%-theme%-secondary%-color", color = "#5a5d64" },
			},

			exclude_filetypes = {},
			exclude_buftypes = {},
		})
	end,
}
</file>

<file path="lua/plugins/treesj.lua">
return {
	"Wansmer/treesj",
	event = "BufRead",
	dependencies = { "nvim-treesitter/nvim-treesitter" },
	config = function()
		local tsj = require("treesj")

		tsj.setup({
			use_default_keymaps = false,
		})

		vim.keymap.set("n", "<leader>xt", tsj.toggle, { desc = "Toggle split" })
		vim.keymap.set("n", "<leader>xT", function()
			tsj.toggle({ split = { recursive = true } })
		end, { desc = "Toggle split recursively" })
		vim.keymap.set("n", "<leader>xj", tsj.join, { desc = "Join" })
		vim.keymap.set("n", "<leader>xs", tsj.split, { desc = "Split" })
	end,
}
</file>

<file path="lua/plugins/coding/nvim-dap.lua">
if true then return {} end
return {
  {
    "mfussenegger/nvim-dap",
    dependencies = {
      "mason-org/mason.nvim",
      "rcarriga/nvim-dap-ui",
      "theHamsta/nvim-dap-virtual-text",
    },
    config = function()
      local dap = require("dap")

      -- Codelldb adapter setup
      dap.adapters.codelldb = {
        type = "server",
        port = "${port}",
        executable = {
          -- Mason installs codelldb here
          command = vim.fn.stdpath("data") .. "/mason/bin/codelldb",
          args = { "--port", "${port}" },
        },
      }

      -- C/C++ configurations
      dap.configurations.cpp = {
        {
          name = "Launch C++ Program",
          type = "codelldb",
          request = "launch",
          program = function()
            return vim.fn.input("Path to executable: ", vim.fn.getcwd() .. "/", "file")
          end,
          cwd = "${workspaceFolder}",
          stopOnEntry = false,
          args = {},

          -- Console setup
          console = "integratedTerminal",

          -- Environment variables
          env = function()
            local variables = {}
            for k, v in pairs(vim.fn.environ()) do
              table.insert(variables, string.format("%s=%s", k, v))
            end
            return variables
          end,
        },
        {
          name = "Launch with Arguments",
          type = "codelldb",
          request = "launch",
          program = function()
            return vim.fn.input("Path to executable: ", vim.fn.getcwd() .. "/", "file")
          end,
          cwd = "${workspaceFolder}",
          stopOnEntry = false,
          args = function()
            local args_input = vim.fn.input("Arguments: ")
            return vim.split(args_input, " ")
          end,
          console = "integratedTerminal",
        },
        {
          name = "Attach to Process",
          type = "codelldb",
          request = "attach",
          pid = require("dap.utils").pick_process,
          args = {},
        },
      }

      -- Use the same configuration for C
      dap.configurations.c = dap.configurations.cpp

      -- Keymaps
      vim.keymap.set("n", "<leader>db", dap.toggle_breakpoint, { desc = "Toggle Breakpoint" })
      vim.keymap.set("n", "<leader>dB", function()
        dap.set_breakpoint(vim.fn.input("Breakpoint condition: "))
      end, { desc = "Conditional Breakpoint" })
      vim.keymap.set("n", "<leader>dc", dap.continue, { desc = "Continue" })
      vim.keymap.set("n", "<leader>dC", dap.run_to_cursor, { desc = "Run to Cursor" })
      vim.keymap.set("n", "<leader>dg", dap.goto_, { desc = "Go to line (no execute)" })
      vim.keymap.set("n", "<leader>di", dap.step_into, { desc = "Step Into" })
      vim.keymap.set("n", "<leader>dj", dap.down, { desc = "Down" })
      vim.keymap.set("n", "<leader>dk", dap.up, { desc = "Up" })
      vim.keymap.set("n", "<leader>dl", dap.run_last, { desc = "Run Last" })
      vim.keymap.set("n", "<leader>do", dap.step_out, { desc = "Step Out" })
      vim.keymap.set("n", "<leader>dO", dap.step_over, { desc = "Step Over" })
      vim.keymap.set("n", "<leader>dp", dap.pause, { desc = "Pause" })
      vim.keymap.set("n", "<leader>dr", dap.repl.toggle, { desc = "Toggle REPL" })
      vim.keymap.set("n", "<leader>ds", dap.session, { desc = "Session" })
      vim.keymap.set("n", "<leader>dt", dap.terminate, { desc = "Terminate" })

      -- Custom debug session for single file C/C++ programs
      vim.keymap.set("n", "<leader>dq", function()
        local filetype = vim.bo.filetype
        if filetype ~= "c" and filetype ~= "cpp" then
          vim.notify("Not a C/C++ file", vim.log.levels.ERROR)
          return
        end

        local filename = vim.fn.expand("%:t:r") -- filename without extension
        local filepath = vim.fn.expand("%:p")   -- full path to current file

        -- Compile command based on filetype
        local compile_cmd
        if filetype == "c" then
          compile_cmd = string.format("gcc -g -o %s %s", filename, filepath)
        else
          compile_cmd = string.format("g++ -g -std=c++17 -o %s %s", filename, filepath)
        end

        -- Compile the program
        vim.notify("Compiling: " .. compile_cmd)
        local result = vim.fn.system(compile_cmd)

        if vim.v.shell_error ~= 0 then
          vim.notify("Compilation failed:\n" .. result, vim.log.levels.ERROR)
          return
        end

        vim.notify("Compilation successful!")

        -- Start debugging
        dap.run({
          name = "Quick Debug",
          type = "codelldb",
          request = "launch",
          program = vim.fn.getcwd() .. "/" .. filename,
          cwd = vim.fn.getcwd(),
          stopOnEntry = false,
          args = {},
          console = "integratedTerminal",
        })
      end, { desc = "Quick Debug (compile & debug current file)" })
    end,
  },

  {
    "rcarriga/nvim-dap-ui",
    dependencies = { "mfussenegger/nvim-dap", "nvim-neotest/nvim-nio" },
    config = function()
      local dap, dapui = require("dap"), require("dapui")

      dapui.setup({
        layouts = {
          {
            elements = {
              { id = "scopes",      size = 0.25 },
              { id = "breakpoints", size = 0.25 },
              { id = "stacks",      size = 0.25 },
              { id = "watches",     size = 0.25 },
            },
            position = "left",
            size = 40,
          },
          {
            elements = {
              { id = "repl",    size = 0.5 },
              { id = "console", size = 0.5 },
            },
            position = "bottom",
            size = 10,
          },
        },
      })

      -- Auto open/close dap-ui
      dap.listeners.after.event_initialized["dapui_config"] = function()
        dapui.open()
      end
      dap.listeners.before.event_terminated["dapui_config"] = function()
        dapui.close()
      end
      dap.listeners.before.event_exited["dapui_config"] = function()
        dapui.close()
      end

      -- Keymaps for dap-ui
      vim.keymap.set("n", "<leader>du", dapui.toggle, { desc = "Toggle Debug UI" })
      vim.keymap.set("n", "<leader>de", dapui.eval, { desc = "Evaluate Expression" })
      vim.keymap.set("v", "<leader>de", dapui.eval, { desc = "Evaluate Selection" })
    end,
  },

  {
    "theHamsta/nvim-dap-virtual-text",
    dependencies = { "mfussenegger/nvim-dap" },
    config = function()
      require("nvim-dap-virtual-text").setup({
        enabled = true,
        enabled_commands = true,
        highlight_changed_variables = true,
        highlight_new_as_changed = false,
        show_stop_reason = true,
        commented = false,
        virt_text_pos = "eol",
        all_frames = false,
        virt_lines = false,
        virt_text_win_col = nil,
      })
    end,
  },
}
</file>

<file path="lua/plugins/comment.lua">
return {
	"numToStr/Comment.nvim",
	event = { "BufReadPre", "BufNewFile" },
	dependencies = {
		"JoosepAlviste/nvim-ts-context-commentstring",
	},
	config = function()
		local comment = require("Comment")
		local ts_context_commentstring = require("ts_context_commentstring.integrations.comment_nvim")

		comment.setup({
			padding = true,
			sticky = false,
			toggler = {
				line = "gcc",
				block = "gbc",
			},
			opleader = {
				line = "gc",
				block = "gb",
			},
			mappings = {
				basic = true,
				extra = false,
			},
			pre_hook = ts_context_commentstring.create_pre_hook(),
		})
	end,
}
</file>

<file path="lua/plugins/lazydev.lua">
return {
  {
    "folke/lazydev.nvim",
    ft = "lua",
    opts = {
      library = {
        { path = "luvit-meta/library", words = { "vim%.uv" } },
        "lazy.nvim",
      },
    },
  },
  { "Bilal2453/luvit-meta", lazy = true },
}
</file>

<file path="lua/plugins/nvim-autopairs.lua">
return {
	"windwp/nvim-autopairs",
	event = { "InsertEnter" },
	config = function()
		local autopairs = require("nvim-autopairs")

		autopairs.setup({
			check_ts = true,
			ts_config = {
				lua = { "string" },
				javascript = { "template_string" },
				java = false,
			},
		})
	end,
}
</file>

<file path="lua/plugins/stcursorword.lua">
return {
  "sontungexpt/stcursorword",
  event = "VeryLazy",
  config = function()
    require("stcursorword").setup({
      excluded = {
        filetypes = {
          "TelescopePrompt",
          "oil_preview",
          "copilot-chat",
          "oil",
          "NvimTree",
          "neo-tree",
          "neo-tree-popup",
          "NeogitStatus",
        },
      },
    })
  end,
}
</file>

<file path="lua/plugins/nvim-surround.lua">
return {
  "kylechui/nvim-surround",
  event = { "BufReadPre", "BufNewFile" },
  config = function()
    require("nvim-surround").setup({
      keymaps = {
        insert = false,
        insert_line = false,
        normal = "ys",           -- ys{motion}{char} - add surround
        normal_cur = "yss",      -- yss{char} - surround line
        normal_line = "yS",      -- yS{motion}{char} - surround line-wise
        normal_cur_line = "ySS", -- ySS{char} - surround whole line
        visual = "S",            -- S{char} - surround selection
        visual_line = "gS",      -- gS{char} - surround linewise
        delete = "ds",           -- ds{char} - delete surround
        change = "cs",           -- cs{old}{new} - change surround
        change_line = "cS",      -- cS{old}{new} - change surround linewise
      },

      surrounds = {
        -- Markdown code blocks
        ["c"] = {
          add = { "```", "```" },
          find = "```.-```",
          delete = "^(...)().-()(...)",
        },
        -- Markdown bold
        ["*"] = {
          add = { "**", "**" },
          find = "%*%*.-%*%*",
          delete = "^(..)().-()(..)",
        },
        -- Markdown italic
        ["_"] = {
          add = { "_", "_" },
          find = "_.-_",
          delete = "^(.)().-(.)()$",
        },
      },
    })
  end,
}

--[[
🎯 HOW TO USE NVIM-SURROUND:

1. ADD SURROUND:
   • Position cursor on word: hello
   • Type: ysiw"
   • Result: "hello"

   • Position cursor anywhere on line: local x = 42
   • Type: yss)
   • Result: (local x = 42)

2. DELETE SURROUND:
   • Position cursor inside: "hello"
   • Type: ds"
   • Result: hello

3. CHANGE SURROUND:
   • Position cursor inside: "hello"
   • Type: cs"'
   • Result: 'hello'

   • Position cursor inside: [hello]
   • Type: cs])
   • Result: (hello)

4. VISUAL MODE:
   • Select text: hello world
   • Type: S"
   • Result: "hello world"

5. ADVANCED EXAMPLES:
   • ysiw}     → {word}
   • ysiwt     → <tag>word</tag> (prompts for tag)
   • yss<p>    → <p>entire line</p>
   • cs"<em>   → "text" becomes <em>text</em>

6. REMEMBER:
   • Open brackets: ( [ { add spaces → ( text )
   • Close brackets: ) ] } no spaces → (text)
   • Most punctuation works: " ' ` ~ + = - *

7. CUSTOM ONES (from config):
   • ysiw*     → **word** (markdown bold)
   • ysiw_     → _word_ (markdown italic)
   • ysiwc     → ```word``` (code block)
--]]
</file>

<file path="lua/plugins/slimline.lua">
return {
  "sschleemilch/slimline.nvim",
  dependencies = {
    "echasnovski/mini.icons",
    "lewis6991/gitsigns.nvim",
  },
  config = function()
    require("mini.icons").setup()

    require("slimline").setup({
      bold = true,
      style = "fg",

      components = {
        left = { "mode", "path", "git" },
        center = {},
        right = { "diagnostics", "progress" },
      },

      configs = {
        mode = {
          verbose = false,
        },
        path = {
          directory = true,
        },
        diagnostics = {
          workspace = false,
        },
        progress = {
          column = false,
        },
      },

      spaces = {
        components = " ",
        left = " ",
        right = " ",
      },

      sep = {
        hide = { first = false, last = false },
        left = "",
        right = "",
      },
    })
  end,
}
</file>

<file path="lua/plugins/coding/nvim-lint.lua">
return {
  "mfussenegger/nvim-lint",
  event = { "BufReadPre", "BufNewFile", "BufWritePost" },
  config = function()
    local lint = require("lint")

    lint.linters_by_ft = {
      -- Web Development
      javascript = { "eslint_d" },
      typescript = { "eslint_d" },
      javascriptreact = { "eslint_d" },
      typescriptreact = { "eslint_d" },
      svelte = { "eslint_d" },
      vue = { "eslint_d" },

      -- Styles
      css = { "stylelint" },
      scss = { "stylelint" },

      -- Shell
      sh = { "shellcheck" },
      bash = { "shellcheck" },
      zsh = { "shellcheck" },

      -- Config files
      dockerfile = { "hadolint" },
      yaml = { "yamllint" },
      json = { "jsonlint" },

      -- C/C++ (only if no LSP or additional checking needed)
      c = { "cpplint" },
      cpp = { "cpplint" },

      -- REMOVED: lua = { "selene" } - let lua_ls handle Lua diagnostics
    }

    -- Simple and safe lint function with comprehensive ignore patterns
    local function lint_current_buffer()
      -- Check if linting is globally disabled
      if vim.g.lint_disabled then
        return
      end

      local bufname = vim.api.nvim_buf_get_name(0)
      if bufname == "" then
        return
      end

      -- Comprehensive ignore patterns to prevent linting unwanted files
      local ignore_patterns = {
        -- Version control
        "%.git/", "%.svn/", "%.hg/",

        -- Dependencies
        "node_modules/", "vendor/", "%.yarn/", "%.pnpm/",

        -- Build directories
        "target/", "build/", "dist/", "out/", "%.next/", "%.nuxt/", "%.vite/", "coverage/",

        -- Cache directories
        "%.cache/", "%.temp/", "%.tmp/", "%.turbo/",

        -- Generated and config files
        "%-lock%.json$", "%.lock$", "%.min%.js$", "%.min%.css$", "%.bundle%.js$",

        -- Config files that usually cause ESLint ignore warnings
        "%.config%.js$", "%.config%.ts$", "%.config%.mjs$",
        "tailwind%.config%.js$", "vite%.config%.js$", "vite%.config%.ts$",
        "next%.config%.js$", "webpack%.config%.js$", "rollup%.config%.js$",
        "postcss%.config%.js$", "babel%.config%.js$"
      }

      -- Check against ignore patterns
      for _, pattern in ipairs(ignore_patterns) do
        if bufname:match(pattern) then
          return
        end
      end

      -- Skip large files for performance
      local max_filesize = 1024 * 1024 -- 1MB
      local ok, stats = pcall(vim.uv.fs_stat, bufname)
      if ok and stats and stats.size and stats.size > max_filesize then
        return
      end

      -- Skip readonly files
      if vim.bo.readonly then
        return
      end

      -- Run the linter
      lint.try_lint()
    end

    -- Debounced linting for better performance
    local timer = nil
    local function debounced_lint()
      if timer then
        timer:stop()
        timer = nil
      end
      timer = vim.defer_fn(function()
        lint_current_buffer()
        timer = nil
      end, 300) -- 300ms debounce
    end

    -- Create autocommand group
    local lint_augroup = vim.api.nvim_create_augroup("lint", { clear = true })

    -- Optimized autocmd events
    vim.api.nvim_create_autocmd({ "BufEnter", "BufWritePost" }, {
      group = lint_augroup,
      callback = lint_current_buffer,
    })

    -- Use debounced version for frequent events
    vim.api.nvim_create_autocmd({ "InsertLeave", "TextChanged" }, {
      group = lint_augroup,
      callback = debounced_lint,
    })

    -- Keymaps
    vim.keymap.set("n", "<leader>cl", function()
      lint.try_lint()
    end, { desc = "Trigger linting for current file" })

    vim.keymap.set("n", "<leader>lt", function()
      vim.g.lint_disabled = not vim.g.lint_disabled
      if vim.g.lint_disabled then
        vim.notify("Linting disabled", vim.log.levels.WARN)
        -- Clear existing diagnostics from all lint namespaces
        for name, _ in pairs(lint.linters) do
          local namespace = lint.get_namespace(name)
          if namespace then
            vim.diagnostic.reset(namespace)
          end
        end
      else
        vim.notify("Linting enabled", vim.log.levels.INFO)
        lint_current_buffer()
      end
    end, { desc = "Toggle linting on/off" })

    vim.keymap.set("n", "<leader>lr", function()
      local running_linters = lint.get_running()
      if #running_linters == 0 then
        vim.notify("No linters running", vim.log.levels.INFO)
      else
        vim.notify("Running linters: " .. table.concat(running_linters, ", "), vim.log.levels.INFO)
      end
    end, { desc = "Show running linters" })
  end,
}
</file>

<file path="lua/core/keymap.lua">
vim.g.mapleader = " "
vim.g.maplocalleader = " "

vim.keymap.set({ "n", "i", "v" }, "<F1>", "<nop>")
vim.keymap.set("n", "<C-h>", "<C-w><C-h>", { desc = "Move focus to the left window" })
vim.keymap.set("n", "<C-l>", "<C-w><C-l>", { desc = "Move focus to the right window" })
vim.keymap.set("n", "<C-j>", "<C-w><C-j>", { desc = "Move focus to the lower window" })
vim.keymap.set("n", "<C-k>", "<C-w><C-k>", { desc = "Move focus to the upper window" })

vim.keymap.set("n", "<leader>-", "<C-w>s", { desc = "Split horizontal" })
vim.keymap.set("n", "<leader>\\", "<C-w>v", { desc = "Split vertical" })

vim.keymap.set("n", "<ESC>", "<cmd>nohlsearch<CR>")

vim.keymap.set("n", "<leader>cd", vim.diagnostic.open_float, { desc = "Show diagnostic Error messages" })
vim.keymap.set("n", "<leader>ca", vim.diagnostic.setloclist, { desc = "Open diagnostic Quickfix list" })

vim.keymap.set("t", "<Esc><Esc>", "<C-\\><C-n>", { desc = "Exit terminal mode" })

vim.keymap.set("n", "<leader>hh", ":tab help<Space>", { desc = "Tab help" })


-- Keymap for easy troubleshooting
vim.keymap.set("n", "<leader>tsd", "<cmd>TSDebug<CR>", { desc = "Debug treesitter" })
vim.keymap.set("n", "<leader>tsr", "<cmd>TSRefresh<CR>", { desc = "Refresh treesitter" })
vim.keymap.set("n", "<leader>tsh", "<cmd>TSHealth<CR>", { desc = "Check treesitter health" })

-- Additional treesitter inspection keymaps
vim.keymap.set("n", "<leader>tsi", function()
  local buf = vim.api.nvim_get_current_buf()
  local cursor = vim.api.nvim_win_get_cursor(0)
  local row, col = cursor[1] - 1, cursor[2]

  local node = vim.treesitter.get_node({ bufnr = buf, pos = { row, col } })
  if node then
    local node_type = node:type()
    local start_row, start_col, end_row, end_col = node:range()

    vim.notify(string.format(
      "Node: %s\nRange: (%d,%d) to (%d,%d)",
      node_type, start_row, start_col, end_row, end_col
    ), vim.log.levels.INFO, { title = "Treesitter Node Info" })
  else
    vim.notify("No treesitter node found at cursor", vim.log.levels.WARN)
  end
end, { desc = "Inspect treesitter node at cursor" })

-- Treesitter highlighting toggle
vim.keymap.set("n", "<leader>tst", function()
  local buf = vim.api.nvim_get_current_buf()
  local enabled = vim.treesitter.highlighter.active[buf] ~= nil

  if enabled then
    vim.treesitter.stop(buf)
    vim.notify("Treesitter highlighting disabled", vim.log.levels.INFO)
  else
    vim.treesitter.start(buf)
    vim.notify("Treesitter highlighting enabled", vim.log.levels.INFO)
  end
end, { desc = "Toggle treesitter highlighting" })

-- Show treesitter capture groups under cursor
vim.keymap.set("n", "<leader>tsc", function()
  local buf = vim.api.nvim_get_current_buf()
  local cursor = vim.api.nvim_win_get_cursor(0)
  local row, col = cursor[1] - 1, cursor[2]

  local captures = vim.treesitter.get_captures_at_pos(buf, row, col)
  if #captures > 0 then
    local capture_names = {}
    for _, capture in ipairs(captures) do
      table.insert(capture_names, capture.capture)
    end
    vim.notify(
      "Captures: " .. table.concat(capture_names, ", "),
      vim.log.levels.INFO,
      { title = "Treesitter Captures" }
    )
  else
    vim.notify("No treesitter captures at cursor", vim.log.levels.WARN)
  end
end, { desc = "Show treesitter captures at cursor" })

-- Modern treesitter playground alternative
vim.keymap.set("n", "<leader>tsp", function()
  local buf = vim.api.nvim_get_current_buf()
  local parser = vim.treesitter.get_parser(buf)

  if not parser then
    vim.notify("No treesitter parser for this buffer", vim.log.levels.ERROR)
    return
  end

  local tree = parser:parse()[1]
  local root = tree:root()

  -- Create a new buffer to show the syntax tree
  local syntax_buf = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_name(syntax_buf, "treesitter-syntax-tree")
  vim.bo[syntax_buf].filetype = "query"
  vim.bo[syntax_buf].modifiable = true

  -- Simple tree representation
  local function node_to_string(node, depth)
    depth = depth or 0
    local indent = string.rep("  ", depth)
    local node_text = string.format("%s(%s)", indent, node:type())

    local lines = { node_text }
    for child in node:iter_children() do
      local child_lines = node_to_string(child, depth + 1)
      for _, line in ipairs(child_lines) do
        table.insert(lines, line)
      end
    end
    return lines
  end

  local tree_lines = node_to_string(root)
  vim.api.nvim_buf_set_lines(syntax_buf, 0, -1, false, tree_lines)
  vim.bo[syntax_buf].modifiable = false

  -- Open in a split
  vim.cmd("split")
  vim.api.nvim_win_set_buf(0, syntax_buf)
  vim.api.nvim_win_set_height(0, math.min(15, #tree_lines))
end, { desc = "Show treesitter syntax tree" })
</file>

<file path="lua/plugins/fidget.lua">
return {
	"j-hui/fidget.nvim",
	config = function()
		require("fidget").setup({
			notification = {
				poll_rate = 10,
				filter = vim.log.levels.INFO,
				history_size = 128,
				override_vim_notify = true,

				view = {
					stack_upwards = true,
					icon_separator = " ",
					group_separator = "---",
					group_separator_hl = "Comment",
					render_message = function(msg, cnt)
						return cnt == 1 and msg or string.format("(%dx) %s", cnt, msg)
					end,
				},

				window = {
					normal_hl = "Comment",
					winblend = 100,
					border = "none",
					zindex = 45,
					max_width = 0,
					max_height = 0,
					x_padding = 1,
					y_padding = 0,
					align = "top",
					relative = "editor",
				},
			},

			integration = {
				["nvim-tree"] = {
					enable = true, -- Integrate with nvim-tree/nvim-tree.lua (if installed)
				},
			},
		})
	end,
}
</file>

<file path="lua/core/command.lua">
vim.api.nvim_create_autocmd("TextYankPost", {
  desc = "Highlight yanking text",
  group = vim.api.nvim_create_augroup("highlight-yank", { clear = true }),
  callback = function()
    vim.highlight.on_yank()
  end,
})

-- Simplified cursorline management - fewer events, better performance
local cursorline_group = vim.api.nvim_create_augroup("CursorLineManagement", { clear = true })

-- Excluded filetypes for cursorline
local excluded_filetypes = {
  "TelescopePrompt", "fzf", "oil_preview", "oil", "copilot-chat",
  "neo-tree", "neo-tree-popup", "NeogitStatus", "lazy", "mason",
  "help", "terminal", "prompt", "nofile"
}

vim.api.nvim_create_autocmd({ "WinEnter", "BufEnter" }, {
  group = cursorline_group,
  callback = function()
    local ft = vim.bo.filetype
    local bt = vim.bo.buftype

    if vim.tbl_contains(excluded_filetypes, ft) or vim.tbl_contains(excluded_filetypes, bt) then
      vim.wo.cursorline = false
    else
      vim.wo.cursorline = true
    end
  end,
})

vim.api.nvim_create_autocmd({ "WinLeave", "BufLeave" }, {
  group = cursorline_group,
  callback = function()
    vim.wo.cursorline = false
  end,
})

-- Single colorscheme handler - consolidate all highlight updates
vim.api.nvim_create_autocmd("ColorScheme", {
  group = cursorline_group,
  callback = function()
    -- Cursorline colors
    local bg = vim.g.colors_name == "gruvbox-material" and "#3c3836" or "#2a2a37"
    vim.api.nvim_set_hl(0, "CursorLine", { bg = bg })
    vim.api.nvim_set_hl(0, "CursorLineNr", { fg = "#fabd2f", bold = true })
  end,
})

-- Background setting
vim.o.background = "dark"
</file>

<file path="init.lua">
require("core.keymap")
require("core.option")
require("core.command")
require("core.lazy")

vim.cmd("colorscheme gruvbox-material")
</file>

<file path="lua/core/lazy.lua">
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"

if not (vim.uv or vim.loop).fs_stat(lazypath) then
  vim.fn.system({
    "git",
    "clone",
    "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable",
    lazypath,
  })
end

vim.opt.rtp:prepend(lazypath)

require("lazy").setup({
  spec = {
    { import = "plugins" },
    { import = "plugins/coding" },
    { import = "plugins/colorschemes" },
  },
  defaults = {
    lazy = false,
    version = false,
  },
  install = {
    missing = true,
  },
  checker = {
    enabled = true,
    notify = true,
    frequency = 10800,
  },
  change_detection = {
    enabled = true,
    notify = true,
  },
  performance = {
    cache = {
      enabled = true,
    },
    reset_packpath = true,
  },
})

vim.keymap.set("n", "<leader>ll", "<cmd>Lazy<CR>", { noremap = true, silent = true })
</file>

<file path="lua/plugins/coding/conform.lua">
return {
  "stevearc/conform.nvim",
  event = { "BufWritePre" },
  cmd = { "ConformInfo" },
  keys = {
    {
      "<leader>ff",
      function()
        require("conform").format({ async = true, lsp_fallback = true })
      end,
      mode = { "n", "v" },
      desc = "Format buffer or selection",
    },
  },
  config = function()
    require("conform").setup({
      formatters_by_ft = {
        lua = { "stylua" },

        javascript = { "prettier" },
        typescript = { "prettier" },
        javascriptreact = { "prettier" },
        typescriptreact = { "prettier" },
        json = { "prettier" },
        jsonc = { "prettier" },
        html = { "prettier" },
        css = { "prettier" },
        scss = { "prettier" },
        yaml = { "prettier" },
        markdown = { "prettier" },

        -- Python
        python = { "isort", "black" },

        -- Shell
        sh = { "shfmt" },
        bash = { "shfmt" },

        -- C/C++
        c = { "clang_format" },
        cpp = { "clang_format" },
        objc = { "clang_format" },
        objcpp = { "clang_format" },

        -- Fallbacks for any file
        ["_"] = { "trim_whitespace" }, -- Clean up whitespace for all files
      },

      -- Smart format on save - only when formatters are available
      format_on_save = function(bufnr)
        -- Skip for large files (>1MB)
        local max_filesize = 1024 * 1024
        local ok, stats = pcall(vim.uv.fs_stat, vim.api.nvim_buf_get_name(bufnr))
        if ok and stats and stats.size and stats.size > max_filesize then
          return
        end

        -- Skip for readonly files
        if vim.bo[bufnr].readonly then
          return
        end

        -- Skip for certain paths
        local bufname = vim.api.nvim_buf_get_name(bufnr)
        local ignore_patterns = { "node_modules", "%.git/", "vendor/", "target/", "build/" }
        for _, pattern in ipairs(ignore_patterns) do
          if bufname:match(pattern) then
            return
          end
        end

        return {
          timeout_ms = 1000,
          lsp_fallback = true,
          quiet = true,
        }
      end,

      formatters = {
        prettier = {
          condition = function(_, ctx)
            local cwd = vim.fs.dirname(ctx.filename)
            local prettier_files = {
              ".prettierrc", ".prettierrc.json", ".prettierrc.js",
              ".prettierrc.yml", ".prettierrc.yaml", "prettier.config.js"
            }

            for _, file in ipairs(prettier_files) do
              if vim.uv.fs_stat(cwd .. "/" .. file) ~= nil then
                return true
              end
            end

            local package_json = cwd .. "/package.json"
            if vim.uv.fs_stat(package_json) ~= nil then
              local ok, content = pcall(vim.fn.readfile, package_json)
              if ok and content then
                local json_str = table.concat(content, "\n")
                return json_str:match('"prettier"') ~= nil
              end
            end

            return true
          end,
        },

        stylua = {
          condition = function(_, ctx)
            local cwd = vim.fs.dirname(ctx.filename)
            return vim.uv.fs_stat(cwd .. "/stylua.toml") ~= nil or
                vim.uv.fs_stat(cwd .. "/.stylua.toml") ~= nil
          end,
        },

        shfmt = {
          prepend_args = { "-i", "2", "-ci" },
        },

        clang_format = {
          condition = function(_, ctx)
            local cwd = vim.fs.dirname(ctx.filename)
            return vim.uv.fs_stat(cwd .. "/.clang-format") ~= nil or
                vim.uv.fs_stat(cwd .. "/_clang-format") ~= nil or
                vim.uv.fs_stat(vim.fn.getcwd() .. "/.clang-format") ~= nil
          end,
          args = { "--style=file" }, -- Use .clang-format file in project
        },
      },

      format_after_save = {
        lsp_fallback = true,
      },

      notify_on_error = true,
      notify_no_formatters = false,
    })

    vim.o.formatexpr = "v:lua.require'conform'.formatexpr()"

    vim.api.nvim_create_user_command("Format", function(args)
      local range = nil
      if args.count ~= -1 then
        local end_line = vim.api.nvim_buf_get_lines(0, args.line2 - 1, args.line2, true)[1]
        range = {
          start = { args.line1, 0 },
          ["end"] = { args.line2, end_line:len() },
        }
      end
      require("conform").format({ async = true, lsp_fallback = true, range = range })
    end, { range = true, desc = "Format buffer or range" })

    vim.api.nvim_create_user_command("FormatToggle", function()
      if vim.g.disable_autoformat then
        vim.g.disable_autoformat = false
        vim.notify("Format on save enabled", vim.log.levels.INFO)
      else
        vim.g.disable_autoformat = true
        vim.notify("Format on save disabled", vim.log.levels.WARN)
      end
    end, { desc = "Toggle format on save" })
  end,
}
</file>

<file path="lua/plugins/colorschemes/gruvbox-material.lua">
return {
  "sainnhe/gruvbox-material",
  lazy = false,
  priority = 1000,
  config = function()
    vim.g.gruvbox_material_background = "hard"
    vim.g.gruvbox_material_foreground = "material"
    vim.g.gruvbox_material_disable_italic_comment = 0
    vim.g.gruvbox_material_enable_italic = 1
    vim.g.gruvbox_material_enable_bold = 1

    vim.cmd.colorscheme("gruvbox-material")
  end,
}
</file>

<file path="lua/plugins/fzf-lua.lua">
return {
  "ibhagwan/fzf-lua",
  dependencies = {
    "nvim-tree/nvim-web-devicons",
  },
  config = function()
    local fzf = require("fzf-lua")

    fzf.setup({
      winopts = {
        height = 0.85,
        width = 0.80,
        preview = {
          default = "bat",
          layout = "horizontal",
          horizontal = "right:50%",
          border = "rounded",
        },
        border = "rounded",
        backdrop = 60,
      },

      keymap = {
        builtin = {
          ["<C-d>"] = "preview-page-down",
          ["<C-u>"] = "preview-page-up",
        },
        fzf = {
          ["ctrl-q"] = "select-all+accept",
          ["ctrl-d"] = "preview-page-down",
          ["ctrl-u"] = "preview-page-up",
        },
      },

      files = {
        prompt = "Files❯ ",
      },

      grep = {
        prompt = "Rg❯ ",
      },

      lsp = {
        prompt = "LSP❯ ",
        jump1 = true,
        ignore_current_line = true,
        async_or_timeout = 5000,
        file_icons = true,
        git_icons = false,
      },

      previewers = {
        bat = {
          cmd = "bat",
          args = "--color=always --style=numbers,changes",
        },
      },
    })

    fzf.register_ui_select()

    vim.keymap.set("n", "<leader>sk", fzf.keymaps, { desc = "Search Keymaps" })
    vim.keymap.set("n", "<leader><leader>", fzf.files, { desc = "Search Files" })
    vim.keymap.set("n", "<leader>/", fzf.live_grep, { desc = "Search by Grep" })
    vim.keymap.set("n", "<leader>sd", fzf.diagnostics_document, { desc = "Search Diagnostics" })
    vim.keymap.set("n", "<leader>sb", fzf.buffers, { desc = "Search Buffers" })
    vim.keymap.set("n", "<leader>sh", fzf.help_tags, { desc = "Search Help Tags" })
    vim.keymap.set("n", "<leader>sm", fzf.marks, { desc = "Search Marks" })
    vim.keymap.set("n", "<leader>so", fzf.oldfiles, { desc = "Search Old Files" })
  end,
}
</file>

<file path="lua/plugins/hlchunk.lua">
return {
  "shellRaining/hlchunk.nvim",
  event = { "BufReadPre", "BufNewFile" },
  config = function()
    require("hlchunk").setup({
      indent = {
        enable = true,
        chars = { "│" },
        exclude_filetypes = {
          "help",
          "terminal",
          "lazy",
          "mason",
          "NvimTree",
          "neo-tree",
          "TelescopePrompt",
          "oil",
          "notify",
        },
      },

      chunk = {
        enable = true,
        chars = {
          horizontal_line = "─",
          vertical_line = "│",
          left_top = "┌",
          left_bottom = "└",
          right_arrow = "─",
        },
        duration = 200,
        delay = 300,
      },
    })
  end,
}
</file>

<file path="lua/plugins/nvim-treesitter.lua">
return {
  {
    "nvim-treesitter/nvim-treesitter",
    build = ":TSUpdate",
    event = { "VeryLazy" },
    config = function()
      require("nvim-treesitter.configs").setup({
        ensure_installed = {
          "javascript", "typescript", "tsx", "bash", "c",
          "html", "lua", "luadoc", "markdown", "vim", "vimdoc", "query"
        },
        auto_install = true,
        sync_install = false,

        highlight = {
          enable = true,
          additional_vim_regex_highlighting = false,

          disable = function(_, buf)
            local max_filesize = 100 * 1024 -- 100 KB
            local ok, stats = pcall(vim.uv.fs_stat, vim.api.nvim_buf_get_name(buf))
            return ok and stats and stats.size > max_filesize
          end,
        },

        indent = {
          enable = true,
          disable = { "python", "yaml" },
        },

        incremental_selection = {
          enable = true,
          keymaps = {
            init_selection = "<C-space>",
            node_incremental = "<C-space>",
            node_decremental = "<BS>",
          },
        },
      })

      -- Modern folding setup (Neovim 0.11+)
      vim.opt.foldmethod = "expr"
      vim.opt.foldexpr = "v:lua.vim.treesitter.foldexpr()"
      vim.opt.foldcolumn = "0"
      vim.opt.foldtext = ""
      vim.opt.foldlevel = 99
      vim.opt.foldlevelstart = 99
      vim.opt.foldenable = true

      -- Single autocmd for large file handling
      local treesitter_group = vim.api.nvim_create_augroup("TreesitterOptimized", { clear = true })

      vim.api.nvim_create_autocmd("BufReadPre", {
        group = treesitter_group,
        callback = function(event)
          local buf = event.buf
          local filename = vim.api.nvim_buf_get_name(buf)

          if filename == "" then return end

          local ok, stats = pcall(vim.uv.fs_stat, filename)
          if ok and stats and stats.size > 1024 * 1024 then -- 1MB
            -- Disable expensive features for large files
            vim.bo[buf].swapfile = false
            vim.bo[buf].undofile = false
            vim.wo.foldenable = false

            if stats.size > 5 * 1024 * 1024 then -- 5MB
              vim.b[buf].ts_highlight = false
            end
          end
        end,
      })
    end,
  },

  {
    "nvim-treesitter/nvim-treesitter-textobjects",
    event = "VeryLazy",
    dependencies = { "nvim-treesitter/nvim-treesitter" },
    config = function()
      require("nvim-treesitter.configs").setup({
        textobjects = {
          select = {
            enable = true,
            lookahead = true,
            keymaps = {
              ["af"] = "@function.outer",
              ["if"] = "@function.inner",
              ["ac"] = "@class.outer",
              ["ic"] = "@class.inner",
            },
          },
          move = {
            enable = true,
            set_jumps = true,
            goto_next_start = {
              ["]f"] = "@function.outer",
              ["]c"] = "@class.outer",
            },
            goto_previous_start = {
              ["[f"] = "@function.outer",
              ["[c"] = "@class.outer",
            },
          },
        },
      })
    end,
  },
}
</file>

<file path="lua/plugins/coding/blink-cmp.lua">
return {
  "saghen/blink.cmp",
  dependencies = {
    "folke/lazydev.nvim",
    "echasnovski/mini.icons",
  },
  version = "1.*",
  build = "cargo build --release",

  opts = {
    keymap = {
      preset = "none",
      ["<C-k>"] = { "select_prev", "fallback" },
      ["<C-j>"] = { "select_next", "fallback" },
      ["<CR>"] = { "accept", "fallback" },
      ["<C-Space>"] = { "show", "fallback" },
      ["<C-e>"] = { "hide", "fallback" },
    },

    sources = {
      default = { "lsp", "path", "buffer", "lazydev" },
      min_keyword_length = 1,

      providers = {
        lazydev = {
          name = "LazyDev",
          module = "lazydev.integrations.blink",
          score_offset = 100,
        },
      },
    },

    completion = {
      accept = {
        auto_brackets = { enabled = false },
      },

      list = {
        selection = {
          preselect = false,
          auto_insert = false,
        },
      },

      documentation = {
        auto_show = true,
        auto_show_delay_ms = 200,
        window = {
          border = "rounded",
          max_width = 80,
          max_height = 20,
        },
      },


      menu = {
        border = "rounded",
        draw = {
          columns = {
            { "kind_icon", gap = 1 },
            { "label",     "label_description", gap = 1 },
            { "kind" },
          },
        },
      },

      ghost_text = { enabled = false },
    },

    appearance = {
      use_nvim_cmp_as_default = true,
      nerd_font_variant = "normal",
    },

    fuzzy = {
      sorts = { "score", "sort_text" },
    },
  },

  config = function(_, opts)
    require("blink.cmp").setup(opts)

    local function setup_highlights()
      if vim.g.colors_name ~= "gruvbox-material" then
        return
      end

      local colors = {
        menu_bg = "#282828",
        selection_bg = "#3c3836",
        border_fg = "#504945",

        lsp_fg = "#a9b665",
        function_fg = "#d3869b",
        keyword_fg = "#d8a657",
        variable_fg = "#83a598",
      }

      vim.api.nvim_set_hl(0, "BlinkCmpMenu", { bg = colors.menu_bg })
      vim.api.nvim_set_hl(0, "BlinkCmpMenuSelection", { bg = colors.selection_bg })
      vim.api.nvim_set_hl(0, "BlinkCmpMenuBorder", { fg = colors.border_fg })
      vim.api.nvim_set_hl(0, "BlinkCmpDoc", { bg = colors.menu_bg })
      vim.api.nvim_set_hl(0, "BlinkCmpDocBorder", { fg = colors.border_fg })

      vim.api.nvim_set_hl(0, "BlinkCmpKindFunction", { fg = colors.function_fg })
      vim.api.nvim_set_hl(0, "BlinkCmpKindMethod", { fg = colors.function_fg })
      vim.api.nvim_set_hl(0, "BlinkCmpKindKeyword", { fg = colors.keyword_fg })
      vim.api.nvim_set_hl(0, "BlinkCmpKindVariable", { fg = colors.variable_fg })
      vim.api.nvim_set_hl(0, "BlinkCmpKindClass", { fg = colors.lsp_fg })
      vim.api.nvim_set_hl(0, "BlinkCmpKindInterface", { fg = colors.lsp_fg })
    end

    setup_highlights()
    vim.api.nvim_create_autocmd("ColorScheme", {
      callback = function()
        vim.schedule(setup_highlights)
      end,
    })
  end,
}
</file>

<file path="lua/plugins/gitsigns.lua">
return {
  "lewis6991/gitsigns.nvim",
  config = function()
    require("gitsigns").setup({
      signs = {
        add = { text = "▎" },
        change = { text = "▎" },
        delete = { text = "" },
        topdelete = { text = "" },
        changedelete = { text = "▎" },
        untracked = { text = "▎" },
      },

      current_line_blame = false,
      current_line_blame_opts = {
        virt_text = true,
        virt_text_pos = "eol",
        delay = 400,
        ignore_whitespace = false,
      },

      on_attach = function(bufnr)
        local gs = package.loaded.gitsigns
        local map = function(mode, key, cmd, desc)
          vim.keymap.set(mode, key, cmd, { buffer = bufnr, silent = true, desc = desc })
        end

        map("n", "]h", gs.next_hunk, "Next Git Hunk")
        map("n", "[h", gs.prev_hunk, "Previous Git Hunk")

        map("n", "gb", gs.toggle_current_line_blame, "Toggle Line Blame")
        map("n", "gB", gs.blame_line, "Blame Line (Full)")

        map("v", "gs", function()
          gs.stage_hunk({ vim.fn.line("."), vim.fn.line("v") })
        end, "Stage Selection")
        map("v", "gr", function()
          gs.reset_hunk({ vim.fn.line("."), vim.fn.line("v") })
        end, "Reset Selection")
      end,
    })
  end,
}
</file>

<file path="lua/core/option.lua">
vim.g.have_nerd_font = true
vim.o.termguicolors = true

vim.opt.number = true
vim.opt.relativenumber = true

vim.opt.clipboard = "unnamedplus"

vim.opt.completeopt = "menuone,noselect,popup"

vim.opt.mouse = "a"
vim.opt.showmode = false

vim.opt.breakindent = true

vim.opt.undofile = true

vim.opt.ignorecase = true
vim.opt.smartcase = true

vim.opt.signcolumn = "auto"

vim.opt.numberwidth = 4

vim.opt.updatetime = 300
vim.opt.timeoutlen = 300

vim.opt.splitright = true
vim.opt.splitbelow = true

vim.opt.list = true
vim.opt.listchars = { tab = "  ", trail = "-", nbsp = "␣" }

vim.opt.inccommand = "split"

vim.opt.cursorline = true
vim.opt.scrolloff = 10

vim.opt.hlsearch = true

vim.opt.expandtab = true
vim.opt.autoindent = true
vim.opt.tabstop = 2

vim.opt.shiftwidth = 2
vim.opt.shiftround = true

vim.opt.linebreak = true
vim.opt.wrap = false

vim.opt.swapfile = false
vim.opt.backup = false
vim.opt.writebackup = false

vim.g.loaded_netrw = 1
vim.g.loaded_netrwPlugin = 1

vim.o.laststatus = 3

vim.o.lazyredraw = true

vim.o.winborder = "rounded"

vim.opt.wildmenu = true
vim.opt.wildmode = "longest,list"
vim.opt.wildoptions = "pum"
vim.opt.wildignorecase = true

vim.opt.wildignore = {
  "*.o", "*.obj", "*.bin", "*.dll", "*.exe",
  "*/.git/*", "*/.svn/*", "*/.hg/*",
  "*/node_modules/*", "*/vendor/*",
  "*.pyc", "*.pyo", "*.pyd", "__pycache__",
  "*.class", "*.jar",
  "*.min.*", "bundle*.js",
  "*.swp", "*.tmp", "*~"
}

vim.g.loaded_node_provider = 0
vim.g.loaded_perl_provider = 0
vim.g.loaded_python3_provider = 0
vim.g.loaded_ruby_provider = 0

vim.opt.pumheight = 15

vim.opt.ttyfast = true

vim.opt.regexpengine = 0
</file>

<file path="lua/plugins/nvim-tree.lua">
return {
  "nvim-tree/nvim-tree.lua",
  version = "*",
  lazy = false,
  dependencies = {
    "nvim-tree/nvim-web-devicons",
  },
  config = function()
    vim.g.loaded_netrw = 1
    vim.g.loaded_netrwPlugin = 1

    require("nvim-tree").setup({
      auto_reload_on_write = true,
      hijack_cursor = false,
      disable_netrw = false,
      hijack_netrw = true,

      view = {
        width = 30,
        side = "left",
        preserve_window_proportions = true,
        number = false,
        relativenumber = false,
        signcolumn = "yes",
        cursorline = true,
        debounce_delay = 15,
      },

      renderer = {
        add_trailing = false,
        group_empty = false,
        full_name = false,
        root_folder_label = ":~:s?$?/..?",
        indent_width = 2,

        highlight_git = "name",
        highlight_diagnostics = "name",
        highlight_opened_files = "none",
        highlight_modified = "none",
        highlight_bookmarks = "none",
        highlight_clipboard = "none",

        icons = {
          git_placement = "after",
          modified_placement = "after",
          padding = " ",
          symlink_arrow = " ➛ ",
          show = {
            file = true,
            folder = true,
            folder_arrow = true,
            git = false,
            modified = false,
            diagnostics = false,
            bookmarks = false,
            hidden = false,
          },
          glyphs = {
            default = "󰈔",
            symlink = "󰌷",
            folder = {
              arrow_closed = "",
              arrow_open = "",
              default = "󰉋",
              open = "󰝰",
              empty = "󰉖",
              empty_open = "󰷏",
              symlink = "󰉒",
              symlink_open = "󰉒",
            },
          },
        },

        decorators = {
          "Git",
          "Diagnostics",
          "Open",
        },

        special_files = { "Cargo.toml", "Makefile", "README.md", "readme.md" },
      },

      git = {
        enable = true,
        show_on_dirs = true,
        show_on_open_dirs = false,
        disable_for_dirs = {},
        timeout = 400,
      },

      diagnostics = {
        enable = true,
        show_on_dirs = false,
        show_on_open_dirs = false,
        debounce_delay = 50,
        severity = {
          min = vim.diagnostic.severity.HINT,
          max = vim.diagnostic.severity.ERROR,
        },
      },

      filters = {
        git_ignored = false,
        dotfiles = false,
        git_clean = false,
        no_buffer = false,
        custom = {},
        exclude = {},
      },

      live_filter = {
        prefix = "[FILTER]: ",
        always_show_folders = false,
      },

      actions = {
        use_system_clipboard = true,
        change_dir = {
          enable = true,
          global = false,
        },
        expand_all = {
          max_folder_discovery = 300,
          exclude = { ".git", "target", "build", "node_modules" },
        },
        open_file = {
          quit_on_open = false,
          eject = true,
          resize_window = true,
          window_picker = {
            enable = true,
            picker = "default",
            chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
            exclude = {
              filetype = { "notify", "packer", "qf", "diff", "fugitive", "fugitiveblame" },
              buftype = { "nofile", "terminal", "help" },
            },
          },
        },
        remove_file = {
          close_window = true,
        },
      },

      notify = {
        threshold = vim.log.levels.WARN,
        absolute_path = false,
      },

      ui = {
        confirm = {
          remove = true,
          trash = true,
          default_yes = false,
        },
      },

      tab = {
        sync = {
          open = false,
          close = false,
        },
      },

      log = {
        enable = false,
      },

      on_attach = function(bufnr)
        local api = require("nvim-tree.api")

        local function opts(desc)
          return { desc = "nvim-tree: " .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true }
        end

        vim.keymap.set('n', '<C-]>', api.tree.change_root_to_node, opts('CD'))
        vim.keymap.set('n', '<C-e>', api.node.open.replace_tree_buffer, opts('Open: In Place'))
        vim.keymap.set('n', '<C-k>', api.node.show_info_popup, opts('Info'))
        vim.keymap.set('n', '<C-r>', api.fs.rename_sub, opts('Rename: Omit Filename'))
        vim.keymap.set('n', '<C-t>', api.node.open.tab, opts('Open: New Tab'))
        vim.keymap.set('n', '<C-v>', api.node.open.vertical, opts('Open: Vertical Split'))
        vim.keymap.set('n', '<C-x>', api.node.open.horizontal, opts('Open: Horizontal Split'))
        vim.keymap.set('n', '<BS>', api.node.navigate.parent_close, opts('Close Directory'))
        vim.keymap.set('n', '<CR>', api.node.open.edit, opts('Open'))
        vim.keymap.set('n', '<Tab>', api.node.open.preview, opts('Open Preview'))
        vim.keymap.set('n', '>', api.node.navigate.sibling.next, opts('Next Sibling'))
        vim.keymap.set('n', '<', api.node.navigate.sibling.prev, opts('Previous Sibling'))
        vim.keymap.set('n', '.', api.node.run.cmd, opts('Run Command'))
        vim.keymap.set('n', '-', api.tree.change_root_to_parent, opts('Up'))
        vim.keymap.set('n', 'a', api.fs.create, opts('Create'))
        vim.keymap.set('n', 'bmv', api.marks.bulk.move, opts('Move Bookmarked'))
        vim.keymap.set('n', 'B', api.tree.toggle_no_buffer_filter, opts('Toggle No Buffer'))
        vim.keymap.set('n', 'c', api.fs.copy.node, opts('Copy'))
        vim.keymap.set('n', 'C', api.tree.toggle_git_clean_filter, opts('Toggle Git Clean'))
        vim.keymap.set('n', '[c', api.node.navigate.git.prev, opts('Prev Git'))
        vim.keymap.set('n', ']c', api.node.navigate.git.next, opts('Next Git'))
        vim.keymap.set('n', 'd', api.fs.remove, opts('Delete'))
        vim.keymap.set('n', 'D', api.fs.trash, opts('Trash'))
        vim.keymap.set('n', 'E', api.tree.expand_all, opts('Expand All'))
        vim.keymap.set('n', 'e', api.fs.rename_basename, opts('Rename: Basename'))
        vim.keymap.set('n', ']e', api.node.navigate.diagnostics.next, opts('Next Diagnostic'))
        vim.keymap.set('n', '[e', api.node.navigate.diagnostics.prev, opts('Prev Diagnostic'))
        vim.keymap.set('n', 'F', api.live_filter.clear, opts('Clean Filter'))
        vim.keymap.set('n', 'f', api.live_filter.start, opts('Filter'))
        vim.keymap.set('n', 'g?', api.tree.toggle_help, opts('Help'))
        vim.keymap.set('n', 'gy', api.fs.copy.absolute_path, opts('Copy Absolute Path'))
        vim.keymap.set('n', 'H', api.tree.toggle_hidden_filter, opts('Toggle Dotfiles'))
        vim.keymap.set('n', 'I', api.tree.toggle_gitignore_filter, opts('Toggle Git Ignore'))
        vim.keymap.set('n', 'J', api.node.navigate.sibling.last, opts('Last Sibling'))
        vim.keymap.set('n', 'K', api.node.navigate.sibling.first, opts('First Sibling'))
        vim.keymap.set('n', 'm', api.marks.toggle, opts('Toggle Bookmark'))
        vim.keymap.set('n', 'o', api.node.open.edit, opts('Open'))
        vim.keymap.set('n', 'O', api.node.open.no_window_picker, opts('Open: No Window Picker'))
        vim.keymap.set('n', 'p', api.fs.paste, opts('Paste'))
        vim.keymap.set('n', 'P', api.node.navigate.parent, opts('Parent Directory'))
        vim.keymap.set('n', 'q', api.tree.close, opts('Close'))
        vim.keymap.set('n', 'r', api.fs.rename, opts('Rename'))
        vim.keymap.set('n', 'R', api.tree.reload, opts('Refresh'))
        vim.keymap.set('n', 's', api.node.run.system, opts('Run System'))
        vim.keymap.set('n', 'S', api.tree.search_node, opts('Search'))
        vim.keymap.set('n', 'U', api.tree.toggle_custom_filter, opts('Toggle Hidden'))
        vim.keymap.set('n', 'W', api.tree.collapse_all, opts('Collapse'))
        vim.keymap.set('n', 'x', api.fs.cut, opts('Cut'))
        vim.keymap.set('n', 'y', api.fs.copy.filename, opts('Copy Name'))
        vim.keymap.set('n', 'Y', api.fs.copy.relative_path, opts('Copy Relative Path'))

        vim.keymap.set('n', '<C-y>', api.fs.copy.absolute_path, opts('Copy Absolute Path to System Clipboard'))
        vim.keymap.set('n', '<leader>y', function()
          api.fs.copy.absolute_path()
          vim.notify("Absolute path copied to system clipboard", vim.log.levels.INFO)
        end, opts('Copy Absolute Path (with notification)'))

        vim.keymap.set('n', '<leader>p', function()
          local clipboard_content = require("nvim-tree.api").fs.print_clipboard()
          if clipboard_content and clipboard_content ~= "" then
            api.fs.paste()
            vim.notify("Files pasted successfully", vim.log.levels.INFO)
          else
            vim.notify("Nothing in clipboard to paste", vim.log.levels.WARN)
          end
        end, opts('Paste with confirmation'))

        vim.keymap.set('n', '<leader>cb', api.fs.print_clipboard, opts('Show Clipboard'))
        vim.keymap.set('n', '<leader>cc', api.fs.clear_clipboard, opts('Clear Clipboard'))
      end,
    })

    local function setup_highlights()
      local colors = {
        fg = "#d4be98",
        bg = "#282828",

        git_add = "#a9b665",
        git_modify = "#d8a657",
        git_delete = "#ea6962",
        git_stage = "#7daea3",
        git_rename = "#d3869b",
        git_ignore = "#928374",

        diag_error = "#ea6962",
        diag_warn = "#d8a657",
        diag_info = "#7daea3",
        diag_hint = "#a9b665",
      }

      vim.api.nvim_set_hl(0, "NvimTreeGitFileNewHL", { fg = colors.git_add })
      vim.api.nvim_set_hl(0, "NvimTreeGitFileDirtyHL", { fg = colors.git_modify })
      vim.api.nvim_set_hl(0, "NvimTreeGitFileDeletedHL", { fg = colors.git_delete })
      vim.api.nvim_set_hl(0, "NvimTreeGitFileStagedHL", { fg = colors.git_stage })
      vim.api.nvim_set_hl(0, "NvimTreeGitFileRenamedHL", { fg = colors.git_rename })
      vim.api.nvim_set_hl(0, "NvimTreeGitFileIgnoredHL", { fg = colors.git_ignore })

      vim.api.nvim_set_hl(0, "NvimTreeDiagnosticErrorFileHL", {
        fg = colors.diag_error,
        underline = true
      })
      vim.api.nvim_set_hl(0, "NvimTreeDiagnosticWarnFileHL", { fg = colors.diag_warn })
      vim.api.nvim_set_hl(0, "NvimTreeDiagnosticInfoFileHL", { fg = colors.diag_info })
      vim.api.nvim_set_hl(0, "NvimTreeDiagnosticHintFileHL", { fg = colors.diag_hint })

      vim.api.nvim_set_hl(0, "NvimTreeNormal", { fg = colors.fg, bg = colors.bg })
      vim.api.nvim_set_hl(0, "NvimTreeFileName", { fg = colors.fg })
      vim.api.nvim_set_hl(0, "NvimTreeFolderName", { fg = colors.fg })
      vim.api.nvim_set_hl(0, "NvimTreeOpenedFolderName", { fg = colors.fg })
      vim.api.nvim_set_hl(0, "NvimTreeRootFolder", { fg = colors.git_add, bold = true })

      vim.api.nvim_set_hl(0, "NvimTreeEndOfBuffer", { fg = colors.bg, bg = colors.bg })
    end

    setup_highlights()
    vim.api.nvim_create_autocmd("ColorScheme", {
      callback = function()
        if vim.g.colors_name == "gruvbox-material" then
          vim.schedule(setup_highlights)
        end
      end,
    })

    vim.keymap.set("n", "<leader>ee", "<cmd>NvimTreeToggle<cr>", { desc = "Toggle nvim-tree" })
    vim.keymap.set("n", "<leader>ef", "<cmd>NvimTreeFindFile<cr>", { desc = "Focus current file" })
    vim.keymap.set("n", "<leader>ec", "<cmd>NvimTreeCollapse<cr>", { desc = "Collapse all" })
    vim.keymap.set("n", "<leader>er", "<cmd>NvimTreeRefresh<cr>", { desc = "Refresh tree" })

    vim.g.nvim_tree_auto_resize = vim.g.nvim_tree_auto_resize or true
    vim.g.nvim_tree_width_mode = vim.g.nvim_tree_width_mode or "fixed"

    local function resize_tree(size)
      vim.cmd("NvimTreeResize " .. size)
    end

    local function resize_tree_relative(delta)
      vim.cmd("NvimTreeResize " .. (delta > 0 and "+" or "") .. delta)
    end

    local function calculate_optimal_width()
      for _, win in ipairs(vim.api.nvim_list_wins()) do
        local buf = vim.api.nvim_win_get_buf(win)
        if vim.bo[buf].filetype == "NvimTree" then
          local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
          local max_length = 0

          for _, line in ipairs(lines) do
            if line:match("%S") then
              local display_width = vim.fn.strdisplaywidth(line)
              max_length = math.max(max_length, display_width)
            end
          end

          local padding = 8
          local optimal_width = math.min(math.max(max_length + padding, 25), 100)
          return optimal_width
        end
      end
      return 30
    end

    local function auto_resize_now()
      if not vim.g.nvim_tree_auto_resize then return end

      vim.schedule(function()
        local optimal_width = calculate_optimal_width()
        resize_tree(optimal_width)
      end)
    end

    vim.keymap.set("n", "<leader>e1", function() resize_tree(20) end, { desc = "Resize tree to 20" })
    vim.keymap.set("n", "<leader>e2", function() resize_tree(30) end, { desc = "Resize tree to 30" })
    vim.keymap.set("n", "<leader>e3", function() resize_tree(40) end, { desc = "Resize tree to 40" })
    vim.keymap.set("n", "<leader>e4", function() resize_tree(50) end, { desc = "Resize tree to 50" })

    vim.keymap.set("n", "<leader>e+", function() resize_tree_relative(5) end, { desc = "Increase tree width" })
    vim.keymap.set("n", "<leader>e-", function() resize_tree_relative(-5) end, { desc = "Decrease tree width" })
    vim.keymap.set("n", "<leader>e=", function() resize_tree_relative(10) end, { desc = "Increase tree width (large)" })
    vim.keymap.set("n", "<leader>e_", function() resize_tree_relative(-10) end, { desc = "Decrease tree width (large)" })

    vim.keymap.set("n", "<leader>ea", function()
      if vim.g.nvim_tree_width_mode == "fixed" then
        require("nvim-tree").setup({
          view = {
            width = {
              min = 20,
              max = 60,
            }
          }
        })
        vim.g.nvim_tree_width_mode = "adaptive"
        vim.notify("Tree width: Adaptive (20-60)", vim.log.levels.INFO)
      else
        require("nvim-tree").setup({
          view = {
            width = 30
          }
        })
        vim.g.nvim_tree_width_mode = "fixed"
        vim.notify("Tree width: Fixed (30)", vim.log.levels.INFO)
      end
    end, { desc = "Toggle adaptive/fixed width" })

    vim.keymap.set("n", "<leader>ew", function()
      local optimal_width = calculate_optimal_width()
      resize_tree(optimal_width)
      vim.notify("Tree resized to fit content: " .. optimal_width, vim.log.levels.INFO)
    end, { desc = "Auto-resize to fit content (manual)" })

    vim.keymap.set("n", "<leader>et", function()
      vim.g.nvim_tree_auto_resize = not vim.g.nvim_tree_auto_resize
      if vim.g.nvim_tree_auto_resize then
        vim.notify("Auto-resize ON: Tree will resize when folders open", vim.log.levels.INFO)
        auto_resize_now()
      else
        vim.notify("Auto-resize OFF: Manual resizing only", vim.log.levels.INFO)
      end
    end, { desc = "Toggle auto-resize on folder open" })

    local nvim_tree_augroup = vim.api.nvim_create_augroup("NvimTreeOptimized", { clear = true })

    vim.api.nvim_create_autocmd({ "BufEnter", "BufWritePost" }, {
      group = nvim_tree_augroup,
      pattern = "NvimTree*",
      callback = function()
        if vim.g.nvim_tree_auto_resize then
          vim.defer_fn(auto_resize_now, 100)
        end
      end,
    })

    vim.api.nvim_create_autocmd("User", {
      group = nvim_tree_augroup,
      pattern = "NvimTreeRefresh",
      callback = function()
        if vim.g.nvim_tree_auto_resize then
          vim.defer_fn(auto_resize_now, 100)
        end
      end,
    })

    vim.api.nvim_create_autocmd("VimResized", {
      group = nvim_tree_augroup,
      callback = function()
        if vim.g.nvim_tree_width_mode == "adaptive" then
          vim.schedule(function()
            for _, win in ipairs(vim.api.nvim_list_wins()) do
              local buf = vim.api.nvim_win_get_buf(win)
              if vim.bo[buf].filetype == "NvimTree" then
                local total_width = vim.o.columns
                local optimal_width = math.min(math.max(math.floor(total_width * 0.2), 20), 60)
                resize_tree(optimal_width)
                break
              end
            end
          end)
        end
      end,
    })

    vim.api.nvim_create_autocmd("VimLeavePre", {
      group = nvim_tree_augroup,
      callback = function()
        pcall(require("nvim-tree.api").tree.close)
      end,
    })
  end,
}
</file>

<file path="lua/plugins/coding/mason.lua">
return {
  {
    "mason-org/mason.nvim",
    lazy = false,
    config = function()
      require("mason").setup({
        ui = {
          icons = {
            package_installed = "✓",
            package_pending = "➜",
            package_uninstalled = "✗",
          },
          border = "rounded",
          width = 0.8,
          height = 0.8,
        },

        PATH = "prepend",
        install_root_dir = vim.fn.stdpath("data") .. "/mason",
        max_concurrent_installers = 6,

        log_level = vim.log.levels.INFO,
        pip = {
          upgrade_pip = false,
        },
      })

      vim.keymap.set("n", "<leader>mm", "<cmd>Mason<CR>", { desc = "Open Mason" })
    end,
  },

  {
    "WhoIsSethDaniel/mason-tool-installer.nvim",
    dependencies = { "mason-org/mason.nvim" },
    config = function()
      require("mason-tool-installer").setup({
        ensure_installed = {
          "stylua", --
          "prettier",
          "shfmt",
          "clang-format", --
        },

        auto_update = true,
        run_on_start = true,
        start_delay = 5000,
        debounce_hours = 48,
      })
    end,
  },

  {
    "rshkarin/mason-nvim-lint",
    dependencies = {
      "mason-org/mason.nvim",
      "mfussenegger/nvim-lint",
    },
    config = function()
      require("mason-nvim-lint").setup({
        automatic_installation = true,

        ensure_installed = {
          "eslint_d",
          "shellcheck",
          "yamllint", --
          "jsonlint", --

          "stylelint",

          "cpplint",

          "hadolint",

        },

        quiet_mode = true,
      })
    end,
  },
}
</file>

<file path="lua/plugins/coding/lspconfig.lua">
return {
  "neovim/nvim-lspconfig",
  event = { "BufReadPre", "BufNewFile" },
  dependencies = {
    "nvim-lua/plenary.nvim",
    { "mason-org/mason-lspconfig.nvim", dependencies = { "mason-org/mason.nvim" } },
  },
  config = function()
    local lspconfig = require("lspconfig")

    -- Enhanced capabilities for better completion
    local capabilities = vim.lsp.protocol.make_client_capabilities()
    if pcall(require, "blink.cmp") then
      capabilities = require("blink.cmp").get_lsp_capabilities(capabilities)
    end

    -- Performance optimizations
    capabilities.textDocument.completion.completionItem.snippetSupport = true
    capabilities.textDocument.completion.completionItem.resolveSupport = {
      properties = { "documentation", "detail", "additionalTextEdits" }
    }

    -- LSP attach function with optimized keymaps and error handling
    vim.api.nvim_create_autocmd("LspAttach", {
      group = vim.api.nvim_create_augroup("UserLspConfig", { clear = true }),
      callback = function(event)
        local opts = { buffer = event.buf, silent = true }
        local client = vim.lsp.get_client_by_id(event.data.client_id)

        -- Safety check
        if not client then
          return
        end

        -- Navigation with fzf-lua (faster than built-in)
        vim.keymap.set("n", "gd", "<cmd>FzfLua lsp_definitions jump1=true ignore_current_line=true<cr>",
          vim.tbl_extend("force", opts, { desc = "Go to definition" }))
        vim.keymap.set("n", "gD", "<cmd>FzfLua lsp_declarations jump1=true ignore_current_line=true<cr>",
          vim.tbl_extend("force", opts, { desc = "Go to declaration" }))
        vim.keymap.set("n", "gr", "<cmd>FzfLua lsp_references jump1=true ignore_current_line=true<cr>",
          vim.tbl_extend("force", opts, { desc = "Show references" }))
        vim.keymap.set("n", "gi", "<cmd>FzfLua lsp_implementations jump1=true ignore_current_line=true<cr>",
          vim.tbl_extend("force", opts, { desc = "Go to implementation" }))
        vim.keymap.set("n", "gt", "<cmd>FzfLua lsp_typedefs jump1=true ignore_current_line=true<cr>",
          vim.tbl_extend("force", opts, { desc = "Go to type definition" }))

        -- Symbols
        vim.keymap.set("n", "<leader>cs", "<cmd>FzfLua lsp_document_symbols<cr>",
          vim.tbl_extend("force", opts, { desc = "Document symbols" }))
        vim.keymap.set("n", "<leader>cS", "<cmd>FzfLua lsp_workspace_symbols<cr>",
          vim.tbl_extend("force", opts, { desc = "Workspace symbols" }))
        vim.keymap.set("n", "<leader>cf", "<cmd>FzfLua lsp_finder<cr>",
          vim.tbl_extend("force", opts, { desc = "LSP Finder (all locations)" }))

        -- Actions
        vim.keymap.set({ "n", "v" }, "<leader>ca", "<cmd>FzfLua lsp_code_actions<cr>",
          vim.tbl_extend("force", opts, { desc = "Code actions" }))
        vim.keymap.set("n", "<leader>cr", vim.lsp.buf.rename,
          vim.tbl_extend("force", opts, { desc = "Rename symbol" }))

        -- Documentation
        vim.keymap.set("n", "K", vim.lsp.buf.hover,
          vim.tbl_extend("force", opts, { desc = "Show hover documentation" }))

        -- Improved diagnostic navigation
        vim.keymap.set("n", "[e", function()
          vim.diagnostic.jump({ severity = vim.diagnostic.severity.ERROR, count = -1 })
        end, vim.tbl_extend("force", opts, { desc = "Previous Error" }))

        vim.keymap.set("n", "]e", function()
          vim.diagnostic.jump({ severity = vim.diagnostic.severity.ERROR, count = 1 })
        end, vim.tbl_extend("force", opts, { desc = "Next Error" }))

        vim.keymap.set("n", "[d", function()
          vim.diagnostic.jump({
            severity = { vim.diagnostic.severity.WARN, vim.diagnostic.severity.HINT, vim.diagnostic.severity.INFO },
            count = -1,
          })
        end, vim.tbl_extend("force", opts, { desc = "Previous Warning/Info/Hint" }))

        vim.keymap.set("n", "]d", function()
          vim.diagnostic.jump({
            severity = { vim.diagnostic.severity.WARN, vim.diagnostic.severity.HINT, vim.diagnostic.severity.INFO },
            count = 1,
          })
        end, vim.tbl_extend("force", opts, { desc = "Next Warning/Info/Hint" }))

        vim.keymap.set("n", "<leader>cd", vim.diagnostic.open_float,
          vim.tbl_extend("force", opts, { desc = "Show diagnostic" }))

        -- Language-specific keymaps
        if client and client.name == "ts_ls" then
          vim.keymap.set("n", "<leader>oi", function()
            local params = {
              command = "_typescript.organizeImports",
              arguments = { vim.api.nvim_buf_get_name(0) },
              title = "Organize Imports",
            }
            vim.lsp.buf_request(0, "workspace/executeCommand", params)
          end, vim.tbl_extend("force", opts, { desc = "Organize imports" }))
        end

        -- C/C++ specific keymaps
        if client and client.name == "clangd" then
          vim.keymap.set("n", "<leader>ch", "<cmd>ClangdSwitchSourceHeader<cr>",
            vim.tbl_extend("force", opts, { desc = "Switch Source/Header (C/C++)" }))
        end
      end,
    })

    -- Optimized diagnostic configuration
    vim.diagnostic.config({
      virtual_text = {
        spacing = 4,
        prefix = "●",
        source = "if_many",
        severity = { min = vim.diagnostic.severity.WARN }, -- Hide hints in virtual text
      },
      signs = {
        text = {
          [vim.diagnostic.severity.ERROR] = "",
          [vim.diagnostic.severity.WARN] = "",
          [vim.diagnostic.severity.INFO] = "",
          [vim.diagnostic.severity.HINT] = "",
        },
      },
      underline = true,
      update_in_insert = false, -- Better performance
      severity_sort = true,
      float = {
        border = "rounded",
        source = true,
        header = "",
        prefix = "",
        focusable = false, -- Prevent accidental focus
      },
    })

    -- Server configurations
    local server_configs = {
      lua_ls = {
        settings = {
          Lua = {
            -- Enhanced Lua settings for better Neovim development
            diagnostics = {
              globals = { "vim" },
              disable = { "missing-fields" }, -- Reduce noise
            },
            workspace = {
              library = vim.api.nvim_get_runtime_file("", true),
              checkThirdParty = false,
              maxPreload = 100000,
              preloadFileSize = 10000,
            },
            telemetry = { enable = false },
            completion = {
              callSnippet = "Replace",
              keywordSnippet = "Replace",
            },
          },
        },
      },

      ts_ls = {
        settings = {
          typescript = {
            inlayHints = {
              includeInlayParameterNameHints = "literal",
              includeInlayParameterNameHintsWhenArgumentMatchesName = false,
              includeInlayFunctionParameterTypeHints = false,
              includeInlayVariableTypeHints = false,
              includeInlayPropertyDeclarationTypeHints = false,
              includeInlayFunctionLikeReturnTypeHints = false,
              includeInlayEnumMemberValueHints = false,
            },
            preferences = {
              importModuleSpecifier = "relative",
            },
          },
          javascript = {
            preferences = {
              importModuleSpecifier = "relative",
            },
          },
        },
      },

      clangd = {
        cmd = {
          "clangd",
          "--background-index",
          "--clang-tidy",
          "--header-insertion=iwyu",
          "--completion-style=detailed",
          "--function-arg-placeholders",
          "--fallback-style=llvm",
          "--pch-storage=memory", -- Performance optimization
        },
        init_options = {
          usePlaceholders = true,
          completeUnimported = true,
          clangdFileStatus = true,
        },
        capabilities = vim.tbl_extend("force", capabilities, {
          offsetEncoding = { "utf-16" },
        }),
      },
    }

    -- Servers that should not provide formatting (handled by conform.nvim)
    local disable_formatting = {
      "ts_ls",
      "lua_ls",
      "clangd",
      "jsonls",
      "yamlls",
      "html",
      "cssls",
    }

    -- Mason LSP setup with performance optimizations
    local mason_lspconfig = require("mason-lspconfig")
    mason_lspconfig.setup({
      ensure_installed = {
        "lua_ls",
        "ts_ls",
        "bashls",
        "jsonls",
        "yamlls",
        "html",
        "cssls",
        "marksman",
        "clangd",
      },
      automatic_installation = true,
      handlers = {
        function(server_name)
          local config = {
            capabilities = capabilities,
            on_attach = function(client, bufnr)
              -- Safety check
              if not client or not client.server_capabilities then
                return
              end

              -- Disable formatting for specific servers
              if vim.tbl_contains(disable_formatting, server_name) then
                client.server_capabilities.documentFormattingProvider = false
                client.server_capabilities.documentRangeFormattingProvider = false
              end

              -- Performance: safely disable hover for very large files
              local bufname = vim.api.nvim_buf_get_name(bufnr)
              local ok, stats = pcall(vim.uv.fs_stat, bufname)
              if ok and stats and stats.size > 500 * 1024 then -- 500KB
                if client.server_capabilities.hoverProvider then
                  client.server_capabilities.hoverProvider = false
                end
              end
            end,
          }

          -- Merge server-specific configurations
          if server_configs[server_name] then
            config = vim.tbl_deep_extend("force", config, server_configs[server_name])
          end

          lspconfig[server_name].setup(config)
        end,
      },
    })

    -- Performance: reduce LSP log level
    vim.lsp.set_log_level("WARN")
  end,
}
</file>

</files>
