This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: ./init.lua, ./lua/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
./
  lua/
    core/
      command.lua
      keymap.lua
      lazy.lua
      option.lua
    plugins/
      coding/
        blink-cmp.lua
        conform.lua
        copilot.lua
        lspconfig.lua
        mason.lua
        neogen.lua
      colorschemes/
        gruvbox-material.lua
        kanagawa.lua
      comment.lua
      dressing.lua
      fidget.lua
      fzf-lua.lua
      gitsigns.lua
      hlchunk.lua
      lazydev.lua
      neogit.lua
      neoscroll.lua
      nvim-autopairs.lua
      nvim-highlight-colors.lua
      nvim-surround.lua
      nvim-tree.lua
      nvim-treesitter.lua
      precognition.lua
      slimline.lua
      stcursorword.lua
      treesj.lua
  init.lua
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="./lua/core/command.lua">
vim.api.nvim_create_autocmd("TextYankPost", {
	desc = "Highlight yanking text",
	group = vim.api.nvim_create_augroup("highlight-yank", { clear = true }),
	callback = function()
		vim.highlight.on_yank()
	end,
})

vim.cmd([[
  augroup CursorLineOnlyInActiveWindow
    autocmd!
    autocmd WinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
  augroup END
]])

vim.o.background = "dark"
</file>

<file path="./lua/core/keymap.lua">
vim.g.mapleader = " "
vim.g.maplocalleader = " "

vim.keymap.set("n", "<C-h>", "<C-w><C-h>", { desc = "Move focus to the left window" })
vim.keymap.set("n", "<C-l>", "<C-w><C-l>", { desc = "Move focus to the right window" })
vim.keymap.set("n", "<C-j>", "<C-w><C-j>", { desc = "Move focus to the lower window" })
vim.keymap.set("n", "<C-k>", "<C-w><C-k>", { desc = "Move focus to the upper window" })

vim.keymap.set("n", "<leader>-", "<C-w>s", { desc = "Split horizontal" })
vim.keymap.set("n", "<leader>\\", "<C-w>v", { desc = "Split vertical" })

vim.keymap.set("n", "<ESC>", "<cmd>nohlsearch<CR>")

vim.keymap.set("n", "[e", vim.diagnostic.goto_prev, { desc = "Go to previous Diagnostic message" })
vim.keymap.set("n", "]e", vim.diagnostic.goto_next, { desc = "Go to next Diagnostic message" })
vim.keymap.set("n", "<leader>cd", vim.diagnostic.open_float, { desc = "Show diagnostic Error messages" })
vim.keymap.set("n", "<leader>ca", vim.diagnostic.setloclist, { desc = "Open diagnostic Quickfix list" })

vim.keymap.set("t", "<Esc><Esc>", "<C-\\><C-n>", { desc = "Exit terminal mode" })

vim.keymap.set("n", "<leader>hh", ":tab help<Space>", { desc = "Tab help" })
</file>

<file path="./lua/core/lazy.lua">
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"

if not (vim.uv or vim.loop).fs_stat(lazypath) then
	vim.fn.system({
		"git",
		"clone",
		"--filter=blob:none",
		"https://github.com/folke/lazy.nvim.git",
		"--branch=stable",
		lazypath,
	})
end

vim.opt.rtp:prepend(lazypath)

require("lazy").setup({
	spec = {
		{ import = "plugins" },
		{ import = "plugins/coding" },
		{ import = "plugins/colorschemes" },
	},
	defaults = {
		lazy = false,
		version = false,
	},
	install = {
		missing = true,
	},
	checker = {
		enabled = true,
		notify = true,
		frequency = 10800,
	},
	change_detection = {
		enabled = true,
		notify = true,
	},
	performance = {
		cache = {
			enabled = true,
		},
		reset_packpath = true,
	},
})

vim.keymap.set("n", "<leader>l", "<cmd>Lazy<CR>", { noremap = true, silent = true })
</file>

<file path="./lua/core/option.lua">
vim.g.have_nerd_font = true
vim.o.termguicolors = true

vim.opt.number = true
vim.opt.relativenumber = true

vim.opt.clipboard = "unnamedplus"

vim.opt.completeopt = "menuone,noselect,popup"

vim.opt.mouse = "a"
vim.opt.showmode = false

vim.opt.breakindent = true

vim.opt.undofile = true

vim.opt.ignorecase = true
vim.opt.smartcase = true

vim.opt.signcolumn = "auto"

vim.opt.numberwidth = 4

vim.opt.updatetime = 1000
vim.opt.timeoutlen = 1000

vim.opt.splitright = true
vim.opt.splitbelow = true

vim.opt.list = true
vim.opt.listchars = { tab = "  ", trail = "-", nbsp = "␣" }

vim.opt.inccommand = "split"

vim.opt.cursorline = false
vim.opt.scrolloff = 10

vim.opt.hlsearch = true

vim.opt.expandtab = true
vim.opt.autoindent = true
vim.opt.tabstop = 2

vim.opt.shiftwidth = 2
vim.opt.shiftround = true

vim.opt.linebreak = true
vim.opt.wrap = false

vim.opt.swapfile = false
vim.opt.backup = false
vim.opt.writebackup = false

vim.g.loaded_netrw = 1
vim.g.loaded_netrwPlugin = 1

vim.o.laststatus = 3

vim.o.lazyredraw = true
</file>

<file path="./lua/plugins/coding/blink-cmp.lua">
return {
	"saghen/blink.cmp",
	dependencies = {
		"folke/lazydev.nvim",
		"rafamadriz/friendly-snippets",
		"fang2hou/blink-copilot",
		"onsails/lspkind.nvim",
		"echasnovski/mini.icons",
		-- "mikavilpas/blink-ripgrep.nvim",
	},
	version = "*",
	opts = {
		keymap = {
			preset = "none",
			["<C-k>"] = { "select_prev", "fallback" },
			["<C-j>"] = { "select_next", "fallback" },
			["<CR>"] = { "accept", "fallback" },
			["<C-b>"] = { "scroll_documentation_up", "fallback" },
			["<C-f>"] = { "scroll_documentation_down", "fallback" },

			["<C-Space>"] = { "show", "fallback" },
		},

		sources = {
			default = {
				"lsp",
				"path",
				"snippets",
				"buffer",
				"lazydev",
				"copilot",
			},

			providers = {

				lazydev = {
					name = "LazyDev",
					module = "lazydev.integrations.blink",
					score_offset = 98,
				},

				lsp = {
					name = "LSP",
					module = "blink.cmp.sources.lsp",
					fallbacks = { "buffer" },

					transform_items = function(_, items)
						return vim.tbl_filter(function(item)
							return item.kind ~= require("blink.cmp.types").CompletionItemKind.Text
						end, items)
					end,

					opts = { tailwind_color_icon = "██" },

					score_offset = 100,
				},

				path = {
					module = "blink.cmp.sources.path",
					fallbacks = { "buffer" },
					opts = {
						trailing_slash = true,
						label_trailing_slash = true,
						get_cwd = function(context)
							return vim.fn.expand(("#%d:p:h"):format(context.bufnr))
						end,
						show_hidden_files_by_default = false,
					},

					score_offset = 90,
				},

				copilot = {
					name = "copilot",
					module = "blink-copilot",
					score_offset = 99,
					async = true,
					opts = {
						-- max_completions = 2,
						max_attempts = 2,
						kind = "Copilot",
						debounce = 1000,
					},

					-- transform_items = function(_, items)
					-- 	local CompletionItemKind = require("blink.cmp.types").CompletionItemKind
					-- 	local kind_idx = #CompletionItemKind + 1
					-- 	CompletionItemKind[kind_idx] = "Copilot"
					-- 	for _, item in ipairs(items) do
					-- 		item.kind = kind_idx
					-- 	end
					-- 	return items
					-- end,
				},
			},
		},

		completion = {
			-- Disable auto brackets
			accept = { auto_brackets = { enabled = false } },

			list = { selection = { preselect = false, auto_insert = false } },

			-- Show documentation when selecting a completion item
			documentation = { auto_show = true, auto_show_delay_ms = 100 },

			-- Display a preview of the selected item on the current line
			ghost_text = { enabled = true },

			menu = {
				draw = {
					columns = {
						{ "label", "label_description", gap = 1 },
						{ "kind_icon", gap = 1, "kind" },
					},
				},
			},
		},

		appearance = {
			use_nvim_cmp_as_default = true,
			nerd_font_variant = "normal",

			kind_icons = {
				Copilot = "",
				Text = "󰉿",
				Method = "󰊕",
				Function = "󰊕",
				Constructor = "󰒓",

				Field = "󰜢",
				Variable = "󰆦",
				Property = "󰖷",

				Class = "󱡠",
				Interface = "󱡠",
				Struct = "󱡠",
				Module = "󰅩",

				Unit = "󰪚",
				Value = "󰦨",
				Enum = "󰦨",
				EnumMember = "󰦨",

				Keyword = "󰻾",
				Constant = "󰏿",

				Snippet = "󱄽",
				Color = "󰏘",
				File = "󰈔",
				Reference = "󰬲",
				Folder = "󰉋",
				Event = "󱐋",
				Operator = "󰪚",
				TypeParameter = "󰬛",
			},
		},
	},
	opts_extend = { "sources.default" },
	config = function(_, opts)
		require("blink.cmp").setup(opts)
	end,
}
</file>

<file path="./lua/plugins/coding/conform.lua">
return {
	"stevearc/conform.nvim",
	event = { "BufWritePre" },
	cmd = { "ConformInfo" },
	keys = {
		{
			-- Format on demand
			"<leader>ff",
			function()
				require("conform").format({ async = true, lsp_fallback = true })
			end,
			mode = { "n", "v" },
			desc = "Format file or range (in visual mode)",
		},
		{
			-- Format and save
			"<leader>F",
			function()
				vim.cmd("write")
				require("conform").format({ async = true, lsp_fallback = true })
			end,
			mode = "n",
			desc = "Save and format",
		},
	},
	opts = {
		formatters_by_ft = {
			lua = { "stylua" },
			python = { "isort", "black" },
			javascript = { "prettier" },
			typescript = { "prettier" },
			javascriptreact = { "prettier" },
			typescriptreact = { "prettier" },
			svelte = { "prettier" },
			css = { "prettier" },
			html = { "prettier" },
			json = { "prettier" },
			yaml = { "prettier" },
			markdown = { "prettier" },
			graphql = { "prettier" },
			liquid = { "prettier" },
			sql = { "sql-formatter" },
			sh = { "shfmt" },
			rust = { "rustfmt" },
			go = { "gofmt", "goimports" },
			["*"] = { "codespell" },
			["_"] = { "trim_whitespace", "trim_newlines" },
		},

		formatters = {
			shfmt = {
				prepend_args = { "-i", "2", "-ci" }, -- Use 2 spaces and indent switch cases
			},
			prettier = {
				-- Override defaults to not conflict with .prettierrc
				prepend_args = {},
			},
			sql_formatter = {
				prepend_args = { "--language", "postgresql" },
			},
		},

		-- Format options
		format_on_save = function(bufnr)
			local ignore_filetypes = { "sql", "liquid" }
			if vim.tbl_contains(ignore_filetypes, vim.bo[bufnr].filetype) then
				return
			end

			-- Check if file is in a node_modules or .git directory
			local bufname = vim.api.nvim_buf_get_name(bufnr)
			if bufname:match("node_modules") or bufname:match("%.git") then
				return
			end

			return {
				timeout_ms = 500,
				lsp_fallback = true,
				async = false,
			}
		end,

		notify_on_error = true,
		format_after_save = false, -- Don't format again after save
	},
	init = function()
		vim.o.formatexpr = "v:lua.require'conform'.formatexpr()"
	end,
}
</file>

<file path="./lua/plugins/coding/copilot.lua">
return {
	{
		"zbirenbaum/copilot.lua",
		cmd = "Copilot",
		event = "InsertEnter",
		dependencies = {
			"windwp/nvim-autopairs",
		},
		config = function()
			require("copilot").setup({
				panel = {
					enabled = false,
					auto_refresh = true,
					layout = {
						position = "bottom",
						ratio = 0.4,
					},
				},
				suggestion = {
					enabled = false,
					auto_trigger = false,
					debounce = 150,
					keymap = {
						accept = false,
						next = "<M-]>",
						prev = "<M-[>",
						dismiss = "<C-]>",
					},
				},
				filetypes = {
					markdown = true,
					help = false,
					gitcommit = false,
					gitrebase = false,
					["."] = false,
					[""] = false,
				},
				copilot_node_command = "node",
				server_opts_overrides = {
					advanced = {
						inlineSuggestCount = 3,
						length = 100,
					},
				},
			})
		end,
	},
	{
		"CopilotC-Nvim/CopilotChat.nvim",
		event = "VeryLazy",
		dependencies = {
			"zbirenbaum/copilot.lua",
			"nvim-lua/plenary.nvim",
		},
		config = function()
			local chat = require("CopilotChat")
			local select = require("CopilotChat.select")

			chat.setup({
				debug = false,
				show_help = false,
				model = "claude-3.7-sonnet-thought",
				-- window = {
				-- 	width = 0.8,
				-- 	height = 0.8,
				-- 	row = 0.1,
				-- 	col = 0.1,
				-- },
				mappings = {
					complete = {
						insert = "<C-x>",
					},
					close = {
						normal = "q",
						insert = "<C-c>",
					},
					reset = {
						normal = "<C-r>",
						insert = "<C-r>",
					},
					submit_prompt = {
						normal = "<CR>",
						insert = "<C-CR>",
					},
				},
			})

			-- Keymaps helper
			local function map(mode, lhs, rhs, opts)
				opts = opts or {}
				opts.noremap = true
				opts.silent = true
				vim.keymap.set(mode, lhs, rhs, opts)
			end

			-- Chat commands
			local chat_commands = {
				{ key = "<leader>cpp", cmd = ":CopilotChatOpen<CR>", desc = "Open Chat" },
				{ key = "<leader>cpt", cmd = ":CopilotChatTests<CR>", desc = "Generate Tests" },
				{ key = "<leader>cpr", cmd = ":CopilotChatReview<CR>", desc = "Review Code" },
			}

			-- Buffer operations
			local buffer_commands = {
				{
					key = "<leader>cpo",
					fn = function()
						vim.cmd("normal! ggVG")
						vim.cmd("CopilotChatOptimize")
					end,
					desc = "Optimize Buffer",
				},
				{
					key = "<leader>cpf",
					fn = function()
						vim.cmd("normal! ggVG")
						vim.cmd("CopilotChatFix")
					end,
					desc = "Fix Buffer",
				},
				{
					key = "<leader>cpe",
					fn = function()
						vim.cmd("normal! ggVG")
						vim.cmd("CopilotChatExplain")
					end,
					desc = "Explain Buffer",
				},
			}

			-- Quick chat with input
			local function quick_chat()
				local input = vim.fn.input("Quick Chat: ")
				if input ~= "" then
					chat.ask(input, { selection = select.buffer })
				end
			end

			-- Register normal mode commands
			for _, cmd in ipairs(chat_commands) do
				map("n", cmd.key, cmd.cmd, { desc = cmd.desc })
			end

			for _, cmd in ipairs(buffer_commands) do
				map("n", cmd.key, cmd.fn, { desc = cmd.desc })
			end

			map({ "n" }, "<leader>cpq", quick_chat, { desc = "Quick Chat" })

			-- Visual mode mappings
			map("v", "<leader>cpo", ":CopilotChatOptimize<CR>", { desc = "Optimize Selection" })
			map("v", "<leader>cpf", ":CopilotChatFix<CR>", { desc = "Fix Selection" })
			map("v", "<leader>cpe", ":CopilotChatExplain<CR>", { desc = "Explain Selection" })
			map(
				"v",
				"<leader>cpq",
				":<C-u>lua require('CopilotChat').ask(vim.fn.input('Quick Chat: '), { selection = require('CopilotChat.select').visual })<CR>",
				{ desc = "Quick Chat (Visual)" }
			)
		end,
	},
}
</file>

<file path="./lua/plugins/coding/lspconfig.lua">
return {
	"neovim/nvim-lspconfig",
	event = { "BufReadPre", "BufNewFile" },
	dependencies = {
		-- "hrsh7th/cmp-nvim-lsp",
		{ "antosha417/nvim-lsp-file-operations", config = true },
		"williamboman/mason-lspconfig.nvim",
		"stevearc/dressing.nvim",
	},
	config = function()
		local lspconfig = require("lspconfig")
		local fzf = require("fzf-lua")

		local keymap = vim.keymap

		vim.api.nvim_create_autocmd("LspAttach", {
			group = vim.api.nvim_create_augroup("UserLspConfig", {}),
			callback = function(ev)
				local opts = { buffer = ev.buf, silent = true }

				opts.desc = "Go to declaration"
				keymap.set("n", "gD", vim.lsp.buf.declaration, opts)

				opts.desc = "Show LSP references"
				keymap.set("n", "gr", fzf.lsp_references, opts)

				opts.desc = "Show LSP definitions"
				keymap.set("n", "gd", fzf.lsp_definitions, opts)

				opts.desc = "Show LSP implementations"
				keymap.set("n", "gi", fzf.lsp_implementations, opts)

				opts.desc = "Show LSP type definitions"
				keymap.set("n", "gt", fzf.lsp_typedefs, opts)

				opts.desc = "See available code actions"
				keymap.set({ "n", "v" }, "<leader>ca", function()
					vim.lsp.buf.code_action({
						-- This will use dressing.nvim for the code action menu
						context = { diagnostics = vim.lsp.diagnostic.get_line_diagnostics() },
						apply = true,
					})
				end, opts)

				opts.desc = "Smart rename"
				keymap.set("n", "<leader>cr", vim.lsp.buf.rename, opts)

				opts.desc = "Show buffer diagnostics"
				keymap.set("n", "<leader>D", fzf.diagnostics_document, opts)

				opts.desc = "Go to previous error"
				keymap.set("n", "[e", function()
					vim.diagnostic.goto_prev({ severity = vim.diagnostic.severity.ERROR })
				end, opts)

				opts.desc = "Go to next error"
				keymap.set("n", "]e", function()
					vim.diagnostic.goto_next({ severity = vim.diagnostic.severity.ERROR })
				end, opts)

				opts.desc = "Go to previous warning/hint"
				keymap.set("n", "[d", function()
					vim.diagnostic.goto_prev({
						severity = { min = vim.diagnostic.severity.HINT, max = vim.diagnostic.severity.WARN },
					})
				end, opts)

				opts.desc = "Go to next warning/hint"
				keymap.set("n", "]d", function()
					vim.diagnostic.goto_next({
						severity = { min = vim.diagnostic.severity.HINT, max = vim.diagnostic.severity.WARN },
					})
				end, opts)

				opts.desc = "Show documentation for what is under cursor"
				keymap.set("n", "K", vim.lsp.buf.hover, opts)

				opts.desc = "Restart LSP"
				keymap.set("n", "<leader>rs", ":LspRestart<CR>", opts)
			end,
		})

		-- local signs = { Error = " ", Warn = " ", Hint = "󰠠 ", Info = " " }
		-- for type, icon in pairs(signs) do
		-- 	local hl = "DiagnosticSign" .. type
		-- 	vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = "" })
		-- end

		for _, diag in ipairs({ "Error", "Warn", "Info", "Hint" }) do
			vim.fn.sign_define("DiagnosticSign" .. diag, {
				text = "",
				texthl = "DiagnosticSign" .. diag,
				linehl = "",
				numhl = "DiagnosticSign" .. diag,
			})
		end

		vim.diagnostic.config({
			signs = true,
			underline = true,
			update_in_insert = false,
			virtual_text = false,
			severity_sort = true,
		})

		---------------------------------------------------------------------
		local capabilities = require("blink.cmp").get_lsp_capabilities()
		local mason_lspconfig = require("mason-lspconfig")

		capabilities.textDocument.foldingRange = {
			dynamicRegistration = false,
			lineFoldingOnly = true,
		}

		mason_lspconfig.setup_handlers({
			function(server_name)
				lspconfig[server_name].setup({
					capabilities = capabilities,
				})
			end,

			["lua_ls"] = function()
				-- configure lua server (with special settings)
				lspconfig["lua_ls"].setup({
					capabilities = capabilities,
					settings = {
						Lua = {
							-- make the language server recognize "vim" global
							diagnostics = {
								globals = { "vim" },
							},
							completion = {
								callSnippet = "Replace",
							},
						},
					},
				})
			end,

			["ts_ls"] = function()
				lspconfig["ts_ls"].setup({
					capabilities = capabilities,
					commands = {
						OrganizeImports = {
							function()
								vim.lsp.buf.execute_command({
									command = "_typescript.organizeImports",
									arguments = { vim.api.nvim_buf_get_name(0) },
								})
							end,
							description = "Organize Imports",
						},
					},
					on_attach = function(client, bufnr)
						local opts = { noremap = true, silent = true, buffer = bufnr }

						vim.keymap.set("n", "<leader>oi", function()
							local params = {
								command = "_typescript.organizeImports",
								arguments = { vim.api.nvim_buf_get_name(0) },
							}

							client.request("workspace/executeCommand", params, function(err, _result, _ctx)
								if err then
									local msg = err.message or "Error organizing imports"
									vim.notify(msg, vim.log.levels.ERROR)
								else
									vim.notify("Imports organized", vim.log.levels.INFO)
								end
							end, bufnr)
						end, opts)
					end,
				})
			end,

			["bashls"] = function()
				lspconfig["bashls"].setup({
					capabilities = capabilities,
				})
			end,
		})
	end,
}
</file>

<file path="./lua/plugins/coding/mason.lua">
return {
	"williamboman/mason.nvim",
	dependencies = {
		-- "hrsh7th/cmp-nvim-lsp",
		"WhoIsSethDaniel/mason-tool-installer.nvim",
		"stevearc/dressing.nvim",
	},
	config = function()
		local mason = require("mason")
		local mason_tool_installer = require("mason-tool-installer")

		mason.setup({
			ui = {
				icons = {
					package_installed = "✓",
					package_pending = "➜",
					package_uninstalled = "✗",
				},
				keymaps = {
					toggle_package_expand = "<CR>",
					install_package = "i",
					update_package = "u",
					check_package_version = "c",
					update_all_packages = "U",
					check_outdated_packages = "C",
					uninstall_package = "X",
					cancel_installation = "<C-c>",
					apply_language_filter = "<C-f>",
				},
			},
		})

		mason_tool_installer.setup({
			ensure_installed = {
				"prettier",
				"stylua",
				"typescript-language-server",
				"lua-language-server",
				"marksman",
				"bash-language-server",
				"shfmt",
			},
		})

		vim.keymap.set("n", "<leader>mm", "<cmd>Mason<CR>", { noremap = true, silent = true })
	end,
}
</file>

<file path="./lua/plugins/coding/neogen.lua">
return {
	"danymat/neogen",
	lazy = false,
	dependencies = {
		"nvim-treesitter/nvim-treesitter",
		"L3MON4D3/LuaSnip",
	},
	keys = {
		{
			"<leader>nf",
			function()
				require("neogen").generate({ type = "func" })
			end,
			desc = "Generate function documentation",
		},
		{
			"<leader>nc",
			function()
				require("neogen").generate({ type = "class" })
			end,
			desc = "Generate class documentation",
		},
		{
			"<leader>nt",
			function()
				require("neogen").generate({ type = "type" })
			end,
			desc = "Generate type documentation",
		},
		{
			"<leader>nF",
			function()
				require("neogen").generate({ type = "file" })
			end,
			desc = "Generate file documentation",
		},
	},
	opts = {
		enabled = true,
		input_after_comment = true, -- Keep your cursor ready to write inside the comment
		snippet_engine = "luasnip",
		languages = {
			lua = {
				template = {
					annotation_convention = "ldoc",
				},
			},
			python = {
				template = {
					annotation_convention = "google_docstrings",
				},
			},
			typescript = {
				template = {
					annotation_convention = "tsdoc",
				},
			},
			javascript = {
				template = {
					annotation_convention = "jsdoc",
				},
			},
			java = {
				template = {
					annotation_convention = "javadoc",
				},
			},
			php = {
				template = {
					annotation_convention = "phpdoc",
				},
			},
			rust = {
				template = {
					annotation_convention = "rustdoc",
				},
			},
		},
		placeholders_text = {
			["description"] = "[TODO:description]",
			["tparam"] = "[TODO:param]",
			["parameter"] = "[TODO:param]",
			["return"] = "[TODO:return]",
			["class"] = "[TODO:class]",
			["throw"] = "[TODO:throw]",
		},
	},
}
</file>

<file path="./lua/plugins/colorschemes/gruvbox-material.lua">
if true then
	return {}
end
return {
	"sainnhe/gruvbox-material",
	event = { "VimEnter", "ColorScheme" },
	lazy = false,
	priority = 1000,
	config = function()
		vim.g.gruvbox_material_foreground = "mix"
		vim.g.gruvbox_material_background = "medium"
		vim.g.gruvbox_material_disable_italic_comment = 0
		vim.g.gruvbox_material_enable_italic = true
		vim.g.gruvbox_material_enable_bold = 1
		-- vim.cmd.colorscheme("gruvbox-material")
	end,
}
</file>

<file path="./lua/plugins/colorschemes/kanagawa.lua">
return {
	"rebelot/kanagawa.nvim",
	event = { "VimEnter", "ColorScheme" },
	lazy = false,
	priority = 1000,
	config = function()
		require("kanagawa").setup({
			compile = false,
			undercurl = true,
			commentStyle = { italic = true },
			functionStyle = {},
			keywordStyle = { italic = true },
			statementStyle = { bold = true },
			typeStyle = {},
			transparent = false,
			dimInactive = false,
			terminalColors = true,
			colors = { --
				palette = {},
				theme = { wave = {}, lotus = {}, dragon = {}, all = {} },
			},
			overrides = function(colors)
				return {}
			end,
			theme = "dragon",
			background = {
				dark = "dragon",
				light = "lotus",
			},
		})

		-- vim.cmd("colorscheme kanagawa")
	end,
}
</file>

<file path="./lua/plugins/comment.lua">
return {
	"numToStr/Comment.nvim",
	event = { "BufReadPre", "BufNewFile" },
	dependencies = {
		"JoosepAlviste/nvim-ts-context-commentstring",
	},
	config = function()
		local comment = require("Comment")
		local ts_context_commentstring = require("ts_context_commentstring.integrations.comment_nvim")

		comment.setup({
			padding = true,
			sticky = false,
			toggler = {
				line = "gcc",
				block = "gbc",
			},
			opleader = {
				line = "gc",
				block = "gb",
			},
			mappings = {
				basic = true,
				extra = false,
			},
			pre_hook = ts_context_commentstring.create_pre_hook(),
		})
	end,
}
</file>

<file path="./lua/plugins/dressing.lua">
return {
	"stevearc/dressing.nvim",
	event = "VeryLazy",
	config = function()
		require("dressing").setup({
			backend = { "fzf_lua", "fzf", "builtin" },
			select = {
				-- Options for built-in selector
				builtin = {
					width = 0.8,
					height = 0.8,
					border = "rounded",
					relative = "editor",
				},
				-- Options for fzf-lua selector
				fzf_lua = {
					winopts = {
						width = 0.8,
						height = 0.8,
						preview = {
							layout = "vertical",
							vertical = "up:40%",
						},
					},
				},
			},
			input = {
				-- Set to false to disable the vim.ui.input implementation
				enabled = true,

				-- Default prompt string
				default_prompt = "Input:",

				-- Can be 'left', 'right', or 'center'
				prompt_align = "left",

				-- When true, <Esc> will close the modal
				insert_only = true,

				-- These are passed to nvim_open_win
				border = "rounded",
				-- 'editor' and 'win' will default to being centered
				relative = "cursor",

				-- These can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
				prefer_width = 40,
				width = nil,
				-- min_width and max_width can be a list of mixed types.
				-- min_width = {20, 0.2} means "the greater of 20 columns or 20% of total"
				max_width = { 140, 0.9 },
				min_width = { 20, 0.2 },

				-- Window transparency (0-100)
				winblend = 10,
				-- Change default highlight groups (see :help winhl)
				winhighlight = "",
			},
		})
	end,
}
</file>

<file path="./lua/plugins/fidget.lua">
return {
	"j-hui/fidget.nvim",
	config = function()
		require("fidget").setup({
			notification = {
				poll_rate = 10,
				filter = vim.log.levels.INFO,
				history_size = 128,
				override_vim_notify = true,

				view = {
					stack_upwards = true,
					icon_separator = " ",
					group_separator = "---",
					group_separator_hl = "Comment",
					render_message = function(msg, cnt)
						return cnt == 1 and msg or string.format("(%dx) %s", cnt, msg)
					end,
				},

				window = {
					normal_hl = "Comment",
					winblend = 100,
					border = "none",
					zindex = 45,
					max_width = 0,
					max_height = 0,
					x_padding = 1,
					y_padding = 0,
					align = "top",
					relative = "editor",
				},
			},

			integration = {
				["nvim-tree"] = {
					enable = true, -- Integrate with nvim-tree/nvim-tree.lua (if installed)
				},
			},
		})
	end,
}
</file>

<file path="./lua/plugins/fzf-lua.lua">
return {
	"ibhagwan/fzf-lua",
	dependencies = {
		"nvim-tree/nvim-web-devicons",
	},
	config = function()
		local fzf = require("fzf-lua")

		local function get_fzf_colors()
			local colorscheme = vim.g.colors_name or "kanagawa"

			local themes = {
				["gruvbox-material"] = {
					bg = "#282828",
					fg = "#d4be98",
					red = "#ea6962",
					green = "#a9b665",
					yellow = "#d8a657",
					blue = "#7daea3",
					purple = "#d3869b",
					aqua = "#89b482",
					gray = "#928374",
					hl = "#fabd2f",
					info = "#83a598",
					search = "#fe8019",
					header = "#d79921",
					pointer = "#fabd2f",
					marker = "#fe8019",
					prompt = "#d3869b",
				},
				["kanagawa"] = {
					bg = "#181616",
					fg = "#C5C9C5",
					red = "#C34043",
					green = "#76946A",
					yellow = "#C0A36E",
					blue = "#7E9CD8",
					purple = "#957FB8",
					aqua = "#7AA89F",
					gray = "#727169",
					hl = "#C34043",
					info = "#7E9CD8",
					search = "#E82424",
					header = "#DCA561",
					pointer = "#9D6F6C",
					marker = "#C34043",
					prompt = "#C34043",
				},
			}

			return themes[colorscheme] or themes["gruvbox-material"]
		end

		local function apply_fzf_colors()
			local colors = get_fzf_colors()
			fzf.setup({
				global_resume = true,
				global_resume_query = true,
				hls = {
					normal = "Normal",
					border = "FloatBorder",
					cursor = "Cursor",
					cursorline = "CursorLine",
					search = "Search",
					scrollbar_f = "PmenuThumb",
					scrollbar_e = "PmenuSbar",
				},
				winopts = {
					height = 0.85,
					width = 0.80,
					preview = {
						default = "bat",
						vertical = "down:45%",
						horizontal = "right:50%",
						layout = "horizontal",
						flip_columns = 100,
					},
					border = "rounded",
					fzf_opts = {
						["--color"] = string.format(
							"bg+:%s,bg:%s,spinner:%s,hl:%s,fg:%s,header:%s,info:%s,pointer:%s,marker:%s,fg+:%s,prompt:%s,hl+:%s",
							colors.bg, -- Background Highlight
							colors.bg, -- Background
							colors.search, -- Spinner (loading indicator)
							colors.hl, -- Highlight
							colors.fg, -- Foreground
							colors.header, -- Header (title)
							colors.info, -- Info text
							colors.pointer, -- Pointer (cursor)
							colors.hl, -- Marker (selection indicator)
							colors.fg, -- Foreground (active)
							colors.hl, -- Prompt color
							colors.hl -- Search Highlight
						),
					},
				},
			})
		end

		apply_fzf_colors()

		vim.api.nvim_create_autocmd("ColorScheme", {
			callback = function()
				vim.schedule(apply_fzf_colors)
			end,
		})

		-- Keymaps
		vim.keymap.set("n", "<leader>sk", fzf.keymaps, { desc = "Search Keymaps" })
		vim.keymap.set("n", "<leader><leader>", fzf.files, { desc = "Search Files" })
		vim.keymap.set("n", "<leader>/", fzf.live_grep, { desc = "Search by Grep" })
		vim.keymap.set("n", "<leader>sd", fzf.diagnostics_document, { desc = "Search Diagnostics" })
		vim.keymap.set("n", "<leader>sb", fzf.buffers, { desc = "Search Buffers" })
		vim.keymap.set("n", "<leader>sh", fzf.help_tags, { desc = "Search Help Tags" })
		vim.keymap.set("n", "<leader>sm", fzf.marks, { desc = "Search Marks" })
		vim.keymap.set("n", "<leader>so", fzf.oldfiles, { desc = "Search Old Files" })
	end,
}
</file>

<file path="./lua/plugins/gitsigns.lua">
return {
	"lewis6991/gitsigns.nvim",
	config = function()
		local scheme = vim.g.colors_name or "gruvbox-material"

		local palette = {
			["gruvbox-material"] = {
				add = "#a9b665",
				change = "#89b482",
				delete = "#ea6962",
				blame = "#d65d0e",
			},
			["kanagawa"] = {
				add = "#98BB6C",
				change = "#7AA89F",
				delete = "#FF5D62",
				blame = "#FFA066",
			},
		}

		local c = palette[scheme] or palette["gruvbox-material"]

		require("gitsigns").setup({
			signs = {
				add = { text = "▎" },
				change = { text = "▎" },
				delete = { text = "" },
				topdelete = { text = "" },
				changedelete = { text = "▎" },
				untracked = { text = "▎" },
			},
			current_line_blame = false,
			current_line_blame_opts = {
				virt_text = true,
				virt_text_pos = "eol",
				delay = 400,
				ignore_whitespace = false,
				virt_text_priority = 100,
				virt_text_hl_group = "GitSignsCurrentLineBlame",
			},
			current_line_blame_formatter = "<author>, <author_time:%Y-%m-%d> - <summary>",

			on_attach = function(bufnr)
				local gs = package.loaded.gitsigns
				local map = function(mode, key, cmd, desc)
					vim.keymap.set(mode, key, cmd, { buffer = bufnr, silent = true, desc = desc })
				end

				-- Navigation
				map("n", "]h", function()
					if vim.wo.diff then
						return "]h"
					end
					vim.schedule(gs.next_hunk)
					return "<Ignore>"
				end, "Next Git Hunk")

				map("n", "[h", function()
					if vim.wo.diff then
						return "[h"
					end
					vim.schedule(gs.prev_hunk)
					return "<Ignore>"
				end, "Previous Git Hunk")

				-- GitSigns actions with "gs" prefix
				map("n", "gsb", gs.toggle_current_line_blame, "Toggle Line Blame")
				map("n", "gsB", gs.blame_line, "Blame Line (Full)")
				map("n", "gsr", gs.reset_hunk, "Reset Hunk")
				map("n", "gsR", gs.reset_buffer, "Reset Buffer")
				map("n", "gss", gs.stage_hunk, "Stage Hunk")
				map("n", "gsS", gs.stage_buffer, "Stage Buffer")
				map("n", "gsu", gs.undo_stage_hunk, "Undo Stage Hunk")
				map("n", "gsd", gs.diffthis, "Diff This")
				map("n", "gsD", function()
					gs.diffthis("~")
				end, "Diff Base")

				-- Visual mode selection
				map("v", "gss", function()
					gs.stage_hunk({ vim.fn.line("."), vim.fn.line("v") })
				end, "Stage Selection")
				map("v", "gsr", function()
					gs.reset_hunk({ vim.fn.line("."), vim.fn.line("v") })
				end, "Reset Selection")
			end,
		})

		-- Apply theme highlights
		vim.api.nvim_set_hl(0, "GitSignsAdd", { fg = c.add })
		vim.api.nvim_set_hl(0, "GitSignsChange", { fg = c.change })
		vim.api.nvim_set_hl(0, "GitSignsDelete", { fg = c.delete })
		vim.api.nvim_set_hl(0, "GitSignsCurrentLineBlame", { fg = c.blame, italic = true })

		-- Sync colors with colorscheme changes
		vim.api.nvim_create_autocmd("ColorScheme", {
			callback = function()
				vim.schedule(function()
					local scheme = vim.g.colors_name or "gruvbox-material"
					local c = palette[scheme] or palette["gruvbox-material"]
					vim.api.nvim_set_hl(0, "GitSignsAdd", { fg = c.add })
					vim.api.nvim_set_hl(0, "GitSignsChange", { fg = c.change })
					vim.api.nvim_set_hl(0, "GitSignsDelete", { fg = c.delete })
					vim.api.nvim_set_hl(0, "GitSignsCurrentLineBlame", { fg = c.blame, italic = true })
				end)
			end,
		})
	end,
}
</file>

<file path="./lua/plugins/hlchunk.lua">
return {
	"shellRaining/hlchunk.nvim",
	event = { "BufReadPre", "BufNewFile" },
	config = function()
		local scheme = vim.g.colors_name or "kanagawa"

		local palette = {
			["gruvbox-material"] = {
				chunk_style = "#d47d26",
			},
			["kanagawa"] = {
				chunk_style = "#FFA066",
			},
		}

		local color = (palette[scheme] or palette["gruvbox-material"]).chunk_style

		require("hlchunk").setup({
			indent = {
				enable = true,
				priority = 10,
				chars = { "│" },
				exclude_filetypes = {
					oil_preview = true,
					oil = true,
					TelescopePrompt = true,
					notify = true,
					copilot_chat = true,
					fidget = true,
					NvimTree = true,
					NeogitStatus = true,
				},
			},
			chunk = {
				enable = true,
				priority = 15,
				chars = {
					horizontal_line = "─",
					vertical_line = "│",
					left_top = "┌",
					left_bottom = "└",
					right_arrow = "─",
				},
				style = color,
				duration = 50,
				delay = 50,
			},
		})

		vim.api.nvim_create_autocmd("ColorScheme", {
			callback = function()
				vim.schedule(function()
					vim.cmd("silent! lua require('hlchunk').disable()")
					vim.cmd("silent! lua require('hlchunk').enable()")
				end)
			end,
		})
	end,
}
</file>

<file path="./lua/plugins/lazydev.lua">
return {
	{
		"folke/lazydev.nvim",
		ft = "lua",
		opts = {
			library = {
				{ path = "luvit-meta/library", words = { "vim%.uv" } },
				"lazy.nvim",
			},
		},
	},
	{ "Bilal2453/luvit-meta", lazy = true },
	-- {
	-- 	"hrsh7th/nvim-cmp",
	-- 	opts = function(_, opts)
	-- 		opts.sources = opts.sources or {}
	-- 		table.insert(opts.sources, {
	-- 			name = "lazydev",
	-- 			group_index = 0,
	-- 		})
	-- 	end,
	-- },
}
</file>

<file path="./lua/plugins/neogit.lua">
return {
	"NeogitOrg/neogit",
	event = { "ColorScheme" },
	dependencies = {
		"nvim-lua/plenary.nvim",
		"sindrets/diffview.nvim",
		"ibhagwan/fzf-lua",
	},
	config = function()
		local neogit = require("neogit")

		neogit.setup({
			integrations = {
				fzf_lua = true,
				diffview = true,
			},
		})

		vim.keymap.set("n", "<leader>gg", neogit.open, { silent = true, noremap = true })
	end,
}
</file>

<file path="./lua/plugins/neoscroll.lua">
return {
	"karb94/neoscroll.nvim",
	opts = {},
}
</file>

<file path="./lua/plugins/nvim-autopairs.lua">
return {
	"windwp/nvim-autopairs",
	event = { "InsertEnter" },
	config = function()
		local autopairs = require("nvim-autopairs")

		autopairs.setup({
			check_ts = true,
			ts_config = {
				lua = { "string" },
				javascript = { "template_string" },
				java = false,
			},
		})
	end,
}
</file>

<file path="./lua/plugins/nvim-highlight-colors.lua">
return {
	"brenoprata10/nvim-highlight-colors",
	config = function()
		require("nvim-highlight-colors").setup({
			render = "background",
			virtual_symbol = "■",
			enable_hex = true,
			enable_short_hex = true,
			enable_rgb = true,
			enable_hsl = true,
			enable_var_usage = true,
			enable_named_colors = true,
			enable_tailwind = false,

			---Set custom colors
			---Label must be properly escaped with '%' to adhere to `string.gmatch`
			--- :help string.gmatch
			custom_colors = {
				{ label = "%-%-theme%-primary%-color", color = "#0f1219" },
				{ label = "%-%-theme%-secondary%-color", color = "#5a5d64" },
			},

			exclude_filetypes = {},
			exclude_buftypes = {},
		})
	end,
}
</file>

<file path="./lua/plugins/nvim-surround.lua">
return {
	"kylechui/nvim-surround",
	event = { "BufReadPre", "BufNewFile" },
	config = function()
		---@diagnostic disable-next-line
		require("nvim-surround").setup({
			keymaps = {
				insert = "<C-g>s",
				insert_line = "<C-g>S",
				normal = "ys",
				normal_cur = "yss",
				normal_line = "yS",
				normal_gcur_gline = "ySS",
				visual = "S",
				visual_line = "gS",
				delete = "ds",
				change = "cs",
				change_line = "cS",
			},
		})
	end,
}
</file>

<file path="./lua/plugins/nvim-tree.lua">
return {
	"nvim-tree/nvim-tree.lua",
	version = "*",
	lazy = false,
	dependencies = {
		"nvim-tree/nvim-web-devicons",
	},
	config = function()
		require("nvim-tree").setup({
			view = {
				adaptive_size = true,
				width = { min = 30, max = 100 },
			},
			sort = {
				sorter = "name",
				folders_first = true,
				files_first = false,
			},
			renderer = {
				special_files = {
					-- "Cargo.toml",
					-- "Makefile",
					-- "README.md",
					-- "readme.md",
					-- "package.json",
				},
				highlight_git = "name",
				highlight_diagnostics = "name",
				highlight_opened_files = "none",
				highlight_modified = "name",
				highlight_bookmarks = "none",
				highlight_clipboard = "name",
				indent_markers = {
					enable = true,
					inline_arrows = true,
					icons = {
						corner = "└",
						edge = "│",
						item = "│",
						bottom = "─",
						none = " ",
					},
				},

				icons = {
					git_placement = "after",
					show = {
						file = true,
						folder = true,
						folder_arrow = true,
						git = false,
						modified = false,
						diagnostics = false,
						bookmarks = false,
					},
				},
			},
			git = {
				enable = true,
				show_on_dirs = true,
				ignore = false,
				show_on_open_dirs = true,
				disable_for_dirs = {},
				timeout = 400,
				cygwin_support = false,
			},
			filters = {
				dotfiles = false,
				custom = {},
				exclude = {},
			},
			diagnostics = {
				enable = true,
				show_on_dirs = true,
				show_on_open_dirs = false,
				debounce_delay = 50,
				severity = {
					min = vim.diagnostic.severity.HINT,
					max = vim.diagnostic.severity.ERROR,
				},
				icons = {
					hint = "󰠠 ",
					info = " ",
					warning = " ",
					error = " ",
				},
			},
			modified = {
				enable = true,
				show_on_dirs = true,
				show_on_open_dirs = false,
			},

			actions = {
				open_file = {
					window_picker = {
						enable = true,
					},
				},
				change_dir = {
					enable = false,
					global = false,
				},
			},

			-- update_focused_file = {
			-- 	enable = true,
			-- 	update_cwd = false,
			-- 	ignore_list = {},
			-- },
		})

		local function set_nvim_tree_highlight()
			local scheme = vim.g.colors_name or "gruvbox-material"

			local palettes = {
				["gruvbox-material"] = {
					fg = "#d4be98",
					bg = "#282828",
					green = "#a9b665",
					aqua = "#89b482",
					yellow = "#d8a657",
					orange = "#e78a4e",
					red = "#ea6962",
					gray = "#928374",
				},
				["kanagawa"] = {
					fg = "#C5C9C5",
					bg = "#1F1F28",
					green = "#98BB6C",
					aqua = "#7AA89F",
					yellow = "#DCA561",
					orange = "#FFA066",
					red = "#E82424",
					gray = "#727169",
				},
			}

			local c = palettes[scheme] or palettes["gruvbox-material"]

			local highlights = {
				{ name = "NvimTreeGitFileNewHL", fg = c.green },
				{ name = "NvimTreeGitFolderNewHL", fg = c.green },
				{ name = "NvimTreeGitFileDirtyHL", fg = c.aqua },
				{ name = "NvimTreeGitFolderDirtyHL", fg = c.aqua },
				{ name = "NvimTreeDiagnosticWarnFileHL", fg = c.yellow, underline = true },
				{ name = "NvimTreeDiagnosticWarnFolderHL", fg = c.yellow, bold = true },
				{ name = "NvimTreeDiagnosticErrorFileHL", fg = c.orange, underline = true },
				{ name = "NvimTreeDiagnosticErrorFolderHL", fg = c.orange, bold = true },
				{ name = "NvimTreeIndentMarker", fg = c.gray },
				{ name = "NvimTreeWindowPicker", fg = c.bg, bg = c.orange, bold = true },
			}

			for _, h in ipairs(highlights) do
				local name = h.name
				h.name = nil
				vim.api.nvim_set_hl(0, name, h)
			end
		end

		-- Apply highlights immediately
		set_nvim_tree_highlight()

		vim.api.nvim_create_autocmd("ColorScheme", {
			callback = function()
				vim.schedule(set_nvim_tree_highlight)
			end,
		})

		local tree_api = require("nvim-tree.api")

		-- Toggle NvimTree
		local nvimTreeFocusOrToggle = function()
			local nvimTree = require("nvim-tree.api")
			local currentBuf = vim.api.nvim_get_current_buf()
			local currentBufFt = vim.api.nvim_get_option_value("filetype", { buf = currentBuf })
			if currentBufFt == "NvimTree" then
				nvimTree.tree.toggle()
			else
				nvimTree.tree.focus()
			end
		end

		vim.keymap.set("n", "<C-t>", nvimTreeFocusOrToggle)

		vim.api.nvim_set_keymap("n", "<leader>e", "<cmd>NvimTreeToggle<CR>", { silent = true, noremap = true })

		-- Set statusline to show the tree name
		tree_api.events.subscribe(tree_api.events.Event.TreeOpen, function()
			local tree_winid = tree_api.tree.winid()

			if tree_winid ~= nil then
				vim.api.nvim_set_option_value("statusline", "%t", { win = tree_winid })
			end
		end)

		-- Change Root To Global Current Working Directory
		local function change_root_to_global_cwd()
			local api = require("nvim-tree.api")
			local global_cwd = vim.fn.getcwd(-1, -1)
			api.tree.change_root(global_cwd)
		end

		vim.keymap.set("n", "<C-c>", change_root_to_global_cwd, { desc = "Change Root To Global CWD", noremap = true })

		local function focus_on_current_file()
			local api = require("nvim-tree.api")

			api.tree.find_file(vim.fn.expand("%:p"), true)
		end

		vim.keymap.set("n", "<C-t>", focus_on_current_file, { desc = "Focus on current file", noremap = true })
	end,
}
</file>

<file path="./lua/plugins/nvim-treesitter.lua">
return {
	{
		"nvim-treesitter/nvim-treesitter",
		build = ":TSUpdate",
		opts = {
			ensure_installed = {
				"javascript",
				"typescript",
				"tsx",
				"bash",
				"c",
				"diff",
				"html",
				"lua",
				"luadoc",
				"markdown",
				"vim",
				"vimdoc",
			},
			auto_install = true,
			highlight = {
				enable = true,
				additional_vim_regex_highlighting = { "ruby" },
			},
			indent = { enable = true, disable = { "ruby" } },
			incremental_selection = {
				enable = true,
				keymaps = {
					init_selection = "<C-space>",
					node_incremental = "<C-space>",
					scope_incremental = false,
					node_decremental = "<C-/>",
				},
			},
		},
		config = function(_, opts)
			require("nvim-treesitter.install").prefer_git = true
			require("nvim-treesitter.configs").setup(opts)
		end,
	},
	{
		"nvim-treesitter/nvim-treesitter-textobjects",
		dependencies = {
			"nvim-treesitter/nvim-treesitter",
		},
		opts = {
			textobjects = {
				select = {
					enable = true,
				},
				move = {
					enable = true,
					set_jumps = true,
					goto_next_start = { ["]f"] = "@function.outer", ["]c"] = "@class.outer" },
					goto_next_end = { ["]]f"] = "@function.outer", ["]]c"] = "@class.outer" },
					goto_previous_start = { ["[f"] = "@function.outer", ["[c"] = "@class.outer" },
					goto_previous_end = { ["[[f"] = "@function.outer", ["[[c"] = "@class.outer" },
				},
			},
		},
		config = function(_, opts)
			require("nvim-treesitter.configs").setup(opts)
		end,
	},
	{
		"nvim-treesitter/nvim-treesitter-context",
		dependencies = {
			"nvim-treesitter/nvim-treesitter",
		},
		opts = {
			enable = true, -- Enable this plugin (Can be enabled/disabled later via commands)
			multiwindow = true, -- Enable multiwindow support.
			max_lines = 0, -- How many lines the window should span. Values <= 0 mean no limit.
			min_window_height = 0, -- Minimum editor window height to enable context. Values <= 0 mean no limit.
			line_numbers = true,
			multiline_threshold = 20, -- Maximum number of lines to show for a single context
			trim_scope = "outer", -- Which context lines to discard if `max_lines` is exceeded. Choices: 'inner', 'outer'
			mode = "cursor", -- Line used to calculate context. Choices: 'cursor', 'topline'
			-- Separator between context and content. Should be a single character string, like '-'.
			-- When separator is set, the context will only show up when there are at least 2 lines above cursorline.
			separator = nil,
			zindex = 20, -- The Z-index of the context window
			on_attach = nil, -- (fun(buf: integer): boolean) return false to disable attaching
		},
		config = function(_, opts)
			require("treesitter-context").setup(opts)

			vim.keymap.set("n", "<leader>tc", "<cmd>TSContextToggle<CR>", { noremap = true, silent = true })
		end,
	},
}
</file>

<file path="./lua/plugins/precognition.lua">
return {
	"tris203/precognition.nvim",
	event = "VeryLazy",
	opts = {
		startVisible = false,
		showBlankVirtLine = true,
		highlightColor = { link = "Comment" },
		hints = {
			Caret = { text = "^", prio = 2 },
			Dollar = { text = "$", prio = 1 },
			MatchingPair = { text = "%", prio = 5 },
			Zero = { text = "0", prio = 1 },
			w = { text = "w", prio = 10 },
			b = { text = "b", prio = 9 },
			e = { text = "e", prio = 8 },
			W = { text = "W", prio = 7 },
			B = { text = "B", prio = 6 },
			E = { text = "E", prio = 5 },
		},
		gutterHints = {
			G = { text = "G", prio = 10 },
			gg = { text = "gg", prio = 9 },
			PrevParagraph = { text = "{", prio = 8 },
			NextParagraph = { text = "}", prio = 8 },
		},
		disabled_fts = {},
	},
	config = function(_, opts)
		require("precognition").setup(opts)

		vim.keymap.set(
			"n",
			"<leader>P",
			"<cmd>lua require('precognition').toggle()<CR>",
			{ noremap = true, silent = true, desc = "Toggle precognition" }
		)
	end,
}
</file>

<file path="./lua/plugins/slimline.lua">
return {
	"sschleemilch/slimline.nvim",
	dependencies = {
		"echasnovski/mini.icons",
		"lewis6991/gitsigns.nvim",
	},
	config = function()
		require("slimline").setup({
			bold = false, -- makes primary parts bold

			-- Global style. Can be overwritten using `configs.<component>.style`
			style = "fg", -- or "fg"

			-- Component placement
			components = {
				left = {
					"mode",
					"path",
					"git",
				},
				center = {},
				right = {
					"diagnostics",
					"filetype_lsp",
					"progress",
				},
			},

			-- Component configuration
			-- `<component>.style` can be used to overwrite the global 'style'
			-- `<component>.hl = { primary = ..., secondary = ...}` can be used to overwrite global ones
			-- `<component>.follow` can point to another component name to follow its style (e.g. 'progress' following 'mode' by default). Follow can be disabled by setting it to `false`
			configs = {
				mode = {
					verbose = false, -- Mode as single letter or as a word
					hl = {
						normal = "Type",
						insert = "Function",
						pending = "Boolean",
						visual = "Keyword",
						command = "String",
					},
				},
				path = {
					directory = true, -- Whether to show the directory
					icons = {
						folder = " ",
						modified = "",
						read_only = "",
					},
				},
				git = {
					icons = {
						branch = "",
						added = "+",
						modified = "~",
						removed = "-",
					},
				},
				diagnostics = {
					workspace = false, -- Whether diagnostics should show workspace diagnostics instead of current buffer
					icons = {
						ERROR = " ",
						WARN = " ",
						HINT = " ",
						INFO = " ",
					},
				},
				filetype_lsp = {},
				progress = {
					follow = "mode",
					column = false, -- Enables a secondary section with the cursor column
					icon = " ",
				},
				recording = {
					icon = " ",
				},
			},

			-- Spacing configuration
			spaces = {
				components = " ", -- string between components
				left = " ", -- string at the start of the line
				right = " ", -- string at the end of the line
			},

			-- Seperator configuartion
			sep = {
				hide = {
					first = false, -- hides the first separator of the line
					last = false, -- hides the last separator of the line
				},
				left = "", -- left separator of components
				right = "", -- right separator of components
			},

			-- Global highlights
			hl = {
				base = "Comment", -- highlight of the background
				primary = "Normal", -- highlight of primary parts (e.g. filename)
				secondary = "Comment", -- highlight of secondary parts (e.g. filepath)
			},
		})
	end,
}
</file>

<file path="./lua/plugins/stcursorword.lua">
return {
	"sontungexpt/stcursorword",
	event = "VeryLazy",
	config = function()
		require("stcursorword").setup({
			excluded = {
				filetypes = {
					"TelescopePrompt",
					"oil_preview",
					"copilot-chat",
					"oil",
					"NvimTree",
					"NeogitStatus",
				},
			},
		})
	end,
}
</file>

<file path="./lua/plugins/treesj.lua">
return {
	"Wansmer/treesj",
	event = "BufRead",
	dependencies = { "nvim-treesitter/nvim-treesitter" },
	config = function()
		local tsj = require("treesj")

		tsj.setup({
			use_default_keymaps = false,
		})

		vim.keymap.set("n", "<leader>xt", tsj.toggle, { desc = "Toggle split" })
		vim.keymap.set("n", "<leader>xT", function()
			tsj.toggle({ split = { recursive = true } })
		end, { desc = "Toggle split recursively" })
		vim.keymap.set("n", "<leader>xj", tsj.join, { desc = "Join" })
		vim.keymap.set("n", "<leader>xs", tsj.split, { desc = "Split" })
	end,
}
</file>

<file path="./init.lua">
require("core.keymap")
require("core.option")
require("core.command")
require("core.lazy")

vim.cmd("colorscheme kanagawa")
</file>

</files>
